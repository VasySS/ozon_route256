// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i workshop-1/internal/usecase.Storage -o storage.go -n StorageMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"
	"workshop-1/internal/domain"

	"github.com/gojuno/minimock/v3"
)

// StorageMock implements mm_usecase.Storage
type StorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateOrder          func(ctx context.Context, currentTime time.Time, order domain.Order) (err error)
	funcCreateOrderOrigin    string
	inspectFuncCreateOrder   func(ctx context.Context, currentTime time.Time, order domain.Order)
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mStorageMockCreateOrder

	funcCreateReturn          func(ctx context.Context, currentTime time.Time, userID int, orderID int) (err error)
	funcCreateReturnOrigin    string
	inspectFuncCreateReturn   func(ctx context.Context, currentTime time.Time, userID int, orderID int)
	afterCreateReturnCounter  uint64
	beforeCreateReturnCounter uint64
	CreateReturnMock          mStorageMockCreateReturn

	funcDeleteOrder          func(ctx context.Context, orderID int) (err error)
	funcDeleteOrderOrigin    string
	inspectFuncDeleteOrder   func(ctx context.Context, orderID int)
	afterDeleteOrderCounter  uint64
	beforeDeleteOrderCounter uint64
	DeleteOrderMock          mStorageMockDeleteOrder

	funcGetOrder          func(ctx context.Context, orderID int, now time.Time) (o1 domain.Order, err error)
	funcGetOrderOrigin    string
	inspectFuncGetOrder   func(ctx context.Context, orderID int, now time.Time)
	afterGetOrderCounter  uint64
	beforeGetOrderCounter uint64
	GetOrderMock          mStorageMockGetOrder

	funcGetOrders          func(ctx context.Context, orderIDs []int) (oa1 []domain.Order, err error)
	funcGetOrdersOrigin    string
	inspectFuncGetOrders   func(ctx context.Context, orderIDs []int)
	afterGetOrdersCounter  uint64
	beforeGetOrdersCounter uint64
	GetOrdersMock          mStorageMockGetOrders

	funcGetOrdersByUserID          func(ctx context.Context, userID int, lastN int) (oa1 []domain.Order, err error)
	funcGetOrdersByUserIDOrigin    string
	inspectFuncGetOrdersByUserID   func(ctx context.Context, userID int, lastN int)
	afterGetOrdersByUserIDCounter  uint64
	beforeGetOrdersByUserIDCounter uint64
	GetOrdersByUserIDMock          mStorageMockGetOrdersByUserID

	funcGetReturn          func(ctx context.Context, orderID int, now time.Time) (o1 domain.OrderReturn, err error)
	funcGetReturnOrigin    string
	inspectFuncGetReturn   func(ctx context.Context, orderID int, now time.Time)
	afterGetReturnCounter  uint64
	beforeGetReturnCounter uint64
	GetReturnMock          mStorageMockGetReturn

	funcGetReturns          func(ctx context.Context, page int, pageSize int) (oa1 []domain.OrderReturn, err error)
	funcGetReturnsOrigin    string
	inspectFuncGetReturns   func(ctx context.Context, page int, pageSize int)
	afterGetReturnsCounter  uint64
	beforeGetReturnsCounter uint64
	GetReturnsMock          mStorageMockGetReturns

	funcUpdateReceiveDates          func(ctx context.Context, currentTime time.Time, orderIDs []int) (err error)
	funcUpdateReceiveDatesOrigin    string
	inspectFuncUpdateReceiveDates   func(ctx context.Context, currentTime time.Time, orderIDs []int)
	afterUpdateReceiveDatesCounter  uint64
	beforeUpdateReceiveDatesCounter uint64
	UpdateReceiveDatesMock          mStorageMockUpdateReceiveDates
}

// NewStorageMock returns a mock for mm_usecase.Storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateOrderMock = mStorageMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*StorageMockCreateOrderParams{}

	m.CreateReturnMock = mStorageMockCreateReturn{mock: m}
	m.CreateReturnMock.callArgs = []*StorageMockCreateReturnParams{}

	m.DeleteOrderMock = mStorageMockDeleteOrder{mock: m}
	m.DeleteOrderMock.callArgs = []*StorageMockDeleteOrderParams{}

	m.GetOrderMock = mStorageMockGetOrder{mock: m}
	m.GetOrderMock.callArgs = []*StorageMockGetOrderParams{}

	m.GetOrdersMock = mStorageMockGetOrders{mock: m}
	m.GetOrdersMock.callArgs = []*StorageMockGetOrdersParams{}

	m.GetOrdersByUserIDMock = mStorageMockGetOrdersByUserID{mock: m}
	m.GetOrdersByUserIDMock.callArgs = []*StorageMockGetOrdersByUserIDParams{}

	m.GetReturnMock = mStorageMockGetReturn{mock: m}
	m.GetReturnMock.callArgs = []*StorageMockGetReturnParams{}

	m.GetReturnsMock = mStorageMockGetReturns{mock: m}
	m.GetReturnsMock.callArgs = []*StorageMockGetReturnsParams{}

	m.UpdateReceiveDatesMock = mStorageMockUpdateReceiveDates{mock: m}
	m.UpdateReceiveDatesMock.callArgs = []*StorageMockUpdateReceiveDatesParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStorageMockCreateOrder struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockCreateOrderExpectation
	expectations       []*StorageMockCreateOrderExpectation

	callArgs []*StorageMockCreateOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockCreateOrderExpectation specifies expectation struct of the Storage.CreateOrder
type StorageMockCreateOrderExpectation struct {
	mock               *StorageMock
	params             *StorageMockCreateOrderParams
	paramPtrs          *StorageMockCreateOrderParamPtrs
	expectationOrigins StorageMockCreateOrderExpectationOrigins
	results            *StorageMockCreateOrderResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockCreateOrderParams contains parameters of the Storage.CreateOrder
type StorageMockCreateOrderParams struct {
	ctx         context.Context
	currentTime time.Time
	order       domain.Order
}

// StorageMockCreateOrderParamPtrs contains pointers to parameters of the Storage.CreateOrder
type StorageMockCreateOrderParamPtrs struct {
	ctx         *context.Context
	currentTime *time.Time
	order       *domain.Order
}

// StorageMockCreateOrderResults contains results of the Storage.CreateOrder
type StorageMockCreateOrderResults struct {
	err error
}

// StorageMockCreateOrderOrigins contains origins of expectations of the Storage.CreateOrder
type StorageMockCreateOrderExpectationOrigins struct {
	origin            string
	originCtx         string
	originCurrentTime string
	originOrder       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateOrder *mStorageMockCreateOrder) Optional() *mStorageMockCreateOrder {
	mmCreateOrder.optional = true
	return mmCreateOrder
}

// Expect sets up expected params for Storage.CreateOrder
func (mmCreateOrder *mStorageMockCreateOrder) Expect(ctx context.Context, currentTime time.Time, order domain.Order) *mStorageMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("StorageMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &StorageMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.paramPtrs != nil {
		mmCreateOrder.mock.t.Fatalf("StorageMock.CreateOrder mock is already set by ExpectParams functions")
	}

	mmCreateOrder.defaultExpectation.params = &StorageMockCreateOrderParams{ctx, currentTime, order}
	mmCreateOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// ExpectCtxParam1 sets up expected param ctx for Storage.CreateOrder
func (mmCreateOrder *mStorageMockCreateOrder) ExpectCtxParam1(ctx context.Context) *mStorageMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("StorageMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &StorageMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.params != nil {
		mmCreateOrder.mock.t.Fatalf("StorageMock.CreateOrder mock is already set by Expect")
	}

	if mmCreateOrder.defaultExpectation.paramPtrs == nil {
		mmCreateOrder.defaultExpectation.paramPtrs = &StorageMockCreateOrderParamPtrs{}
	}
	mmCreateOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateOrder
}

// ExpectCurrentTimeParam2 sets up expected param currentTime for Storage.CreateOrder
func (mmCreateOrder *mStorageMockCreateOrder) ExpectCurrentTimeParam2(currentTime time.Time) *mStorageMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("StorageMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &StorageMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.params != nil {
		mmCreateOrder.mock.t.Fatalf("StorageMock.CreateOrder mock is already set by Expect")
	}

	if mmCreateOrder.defaultExpectation.paramPtrs == nil {
		mmCreateOrder.defaultExpectation.paramPtrs = &StorageMockCreateOrderParamPtrs{}
	}
	mmCreateOrder.defaultExpectation.paramPtrs.currentTime = &currentTime
	mmCreateOrder.defaultExpectation.expectationOrigins.originCurrentTime = minimock.CallerInfo(1)

	return mmCreateOrder
}

// ExpectOrderParam3 sets up expected param order for Storage.CreateOrder
func (mmCreateOrder *mStorageMockCreateOrder) ExpectOrderParam3(order domain.Order) *mStorageMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("StorageMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &StorageMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.params != nil {
		mmCreateOrder.mock.t.Fatalf("StorageMock.CreateOrder mock is already set by Expect")
	}

	if mmCreateOrder.defaultExpectation.paramPtrs == nil {
		mmCreateOrder.defaultExpectation.paramPtrs = &StorageMockCreateOrderParamPtrs{}
	}
	mmCreateOrder.defaultExpectation.paramPtrs.order = &order
	mmCreateOrder.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the Storage.CreateOrder
func (mmCreateOrder *mStorageMockCreateOrder) Inspect(f func(ctx context.Context, currentTime time.Time, order domain.Order)) *mStorageMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for StorageMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by Storage.CreateOrder
func (mmCreateOrder *mStorageMockCreateOrder) Return(err error) *StorageMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("StorageMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &StorageMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &StorageMockCreateOrderResults{err}
	mmCreateOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateOrder.mock
}

// Set uses given function f to mock the Storage.CreateOrder method
func (mmCreateOrder *mStorageMockCreateOrder) Set(f func(ctx context.Context, currentTime time.Time, order domain.Order) (err error)) *StorageMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the Storage.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the Storage.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	mmCreateOrder.mock.funcCreateOrderOrigin = minimock.CallerInfo(1)
	return mmCreateOrder.mock
}

// When sets expectation for the Storage.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mStorageMockCreateOrder) When(ctx context.Context, currentTime time.Time, order domain.Order) *StorageMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("StorageMock.CreateOrder mock is already set by Set")
	}

	expectation := &StorageMockCreateOrderExpectation{
		mock:               mmCreateOrder.mock,
		params:             &StorageMockCreateOrderParams{ctx, currentTime, order},
		expectationOrigins: StorageMockCreateOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up Storage.CreateOrder return parameters for the expectation previously defined by the When method
func (e *StorageMockCreateOrderExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockCreateOrderResults{err}
	return e.mock
}

// Times sets number of times Storage.CreateOrder should be invoked
func (mmCreateOrder *mStorageMockCreateOrder) Times(n uint64) *mStorageMockCreateOrder {
	if n == 0 {
		mmCreateOrder.mock.t.Fatalf("Times of StorageMock.CreateOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateOrder.expectedInvocations, n)
	mmCreateOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateOrder
}

func (mmCreateOrder *mStorageMockCreateOrder) invocationsDone() bool {
	if len(mmCreateOrder.expectations) == 0 && mmCreateOrder.defaultExpectation == nil && mmCreateOrder.mock.funcCreateOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateOrder.mock.afterCreateOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateOrder implements mm_usecase.Storage
func (mmCreateOrder *StorageMock) CreateOrder(ctx context.Context, currentTime time.Time, order domain.Order) (err error) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	mmCreateOrder.t.Helper()

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(ctx, currentTime, order)
	}

	mm_params := StorageMockCreateOrderParams{ctx, currentTime, order}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, &mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_want_ptrs := mmCreateOrder.CreateOrderMock.defaultExpectation.paramPtrs

		mm_got := StorageMockCreateOrderParams{ctx, currentTime, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateOrder.t.Errorf("StorageMock.CreateOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.currentTime != nil && !minimock.Equal(*mm_want_ptrs.currentTime, mm_got.currentTime) {
				mmCreateOrder.t.Errorf("StorageMock.CreateOrder got unexpected parameter currentTime, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.originCurrentTime, *mm_want_ptrs.currentTime, mm_got.currentTime, minimock.Diff(*mm_want_ptrs.currentTime, mm_got.currentTime))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmCreateOrder.t.Errorf("StorageMock.CreateOrder got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("StorageMock.CreateOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrder.t.Fatal("No results are set for the StorageMock.CreateOrder")
		}
		return (*mm_results).err
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(ctx, currentTime, order)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to StorageMock.CreateOrder. %v %v %v", ctx, currentTime, order)
	return
}

// CreateOrderAfterCounter returns a count of finished StorageMock.CreateOrder invocations
func (mmCreateOrder *StorageMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of StorageMock.CreateOrder invocations
func (mmCreateOrder *StorageMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mStorageMockCreateOrder) Calls() []*StorageMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*StorageMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockCreateOrderDone() bool {
	if m.CreateOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateOrderMock.invocationsDone()
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *StorageMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.CreateOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateOrderCounter := mm_atomic.LoadUint64(&m.afterCreateOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && afterCreateOrderCounter < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.CreateOrder at\n%s", m.CreateOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.CreateOrder at\n%s with params: %#v", m.CreateOrderMock.defaultExpectation.expectationOrigins.origin, *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && afterCreateOrderCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.CreateOrder at\n%s", m.funcCreateOrderOrigin)
	}

	if !m.CreateOrderMock.invocationsDone() && afterCreateOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.CreateOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateOrderMock.expectedInvocations), m.CreateOrderMock.expectedInvocationsOrigin, afterCreateOrderCounter)
	}
}

type mStorageMockCreateReturn struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockCreateReturnExpectation
	expectations       []*StorageMockCreateReturnExpectation

	callArgs []*StorageMockCreateReturnParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockCreateReturnExpectation specifies expectation struct of the Storage.CreateReturn
type StorageMockCreateReturnExpectation struct {
	mock               *StorageMock
	params             *StorageMockCreateReturnParams
	paramPtrs          *StorageMockCreateReturnParamPtrs
	expectationOrigins StorageMockCreateReturnExpectationOrigins
	results            *StorageMockCreateReturnResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockCreateReturnParams contains parameters of the Storage.CreateReturn
type StorageMockCreateReturnParams struct {
	ctx         context.Context
	currentTime time.Time
	userID      int
	orderID     int
}

// StorageMockCreateReturnParamPtrs contains pointers to parameters of the Storage.CreateReturn
type StorageMockCreateReturnParamPtrs struct {
	ctx         *context.Context
	currentTime *time.Time
	userID      *int
	orderID     *int
}

// StorageMockCreateReturnResults contains results of the Storage.CreateReturn
type StorageMockCreateReturnResults struct {
	err error
}

// StorageMockCreateReturnOrigins contains origins of expectations of the Storage.CreateReturn
type StorageMockCreateReturnExpectationOrigins struct {
	origin            string
	originCtx         string
	originCurrentTime string
	originUserID      string
	originOrderID     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateReturn *mStorageMockCreateReturn) Optional() *mStorageMockCreateReturn {
	mmCreateReturn.optional = true
	return mmCreateReturn
}

// Expect sets up expected params for Storage.CreateReturn
func (mmCreateReturn *mStorageMockCreateReturn) Expect(ctx context.Context, currentTime time.Time, userID int, orderID int) *mStorageMockCreateReturn {
	if mmCreateReturn.mock.funcCreateReturn != nil {
		mmCreateReturn.mock.t.Fatalf("StorageMock.CreateReturn mock is already set by Set")
	}

	if mmCreateReturn.defaultExpectation == nil {
		mmCreateReturn.defaultExpectation = &StorageMockCreateReturnExpectation{}
	}

	if mmCreateReturn.defaultExpectation.paramPtrs != nil {
		mmCreateReturn.mock.t.Fatalf("StorageMock.CreateReturn mock is already set by ExpectParams functions")
	}

	mmCreateReturn.defaultExpectation.params = &StorageMockCreateReturnParams{ctx, currentTime, userID, orderID}
	mmCreateReturn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateReturn.expectations {
		if minimock.Equal(e.params, mmCreateReturn.defaultExpectation.params) {
			mmCreateReturn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateReturn.defaultExpectation.params)
		}
	}

	return mmCreateReturn
}

// ExpectCtxParam1 sets up expected param ctx for Storage.CreateReturn
func (mmCreateReturn *mStorageMockCreateReturn) ExpectCtxParam1(ctx context.Context) *mStorageMockCreateReturn {
	if mmCreateReturn.mock.funcCreateReturn != nil {
		mmCreateReturn.mock.t.Fatalf("StorageMock.CreateReturn mock is already set by Set")
	}

	if mmCreateReturn.defaultExpectation == nil {
		mmCreateReturn.defaultExpectation = &StorageMockCreateReturnExpectation{}
	}

	if mmCreateReturn.defaultExpectation.params != nil {
		mmCreateReturn.mock.t.Fatalf("StorageMock.CreateReturn mock is already set by Expect")
	}

	if mmCreateReturn.defaultExpectation.paramPtrs == nil {
		mmCreateReturn.defaultExpectation.paramPtrs = &StorageMockCreateReturnParamPtrs{}
	}
	mmCreateReturn.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateReturn.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateReturn
}

// ExpectCurrentTimeParam2 sets up expected param currentTime for Storage.CreateReturn
func (mmCreateReturn *mStorageMockCreateReturn) ExpectCurrentTimeParam2(currentTime time.Time) *mStorageMockCreateReturn {
	if mmCreateReturn.mock.funcCreateReturn != nil {
		mmCreateReturn.mock.t.Fatalf("StorageMock.CreateReturn mock is already set by Set")
	}

	if mmCreateReturn.defaultExpectation == nil {
		mmCreateReturn.defaultExpectation = &StorageMockCreateReturnExpectation{}
	}

	if mmCreateReturn.defaultExpectation.params != nil {
		mmCreateReturn.mock.t.Fatalf("StorageMock.CreateReturn mock is already set by Expect")
	}

	if mmCreateReturn.defaultExpectation.paramPtrs == nil {
		mmCreateReturn.defaultExpectation.paramPtrs = &StorageMockCreateReturnParamPtrs{}
	}
	mmCreateReturn.defaultExpectation.paramPtrs.currentTime = &currentTime
	mmCreateReturn.defaultExpectation.expectationOrigins.originCurrentTime = minimock.CallerInfo(1)

	return mmCreateReturn
}

// ExpectUserIDParam3 sets up expected param userID for Storage.CreateReturn
func (mmCreateReturn *mStorageMockCreateReturn) ExpectUserIDParam3(userID int) *mStorageMockCreateReturn {
	if mmCreateReturn.mock.funcCreateReturn != nil {
		mmCreateReturn.mock.t.Fatalf("StorageMock.CreateReturn mock is already set by Set")
	}

	if mmCreateReturn.defaultExpectation == nil {
		mmCreateReturn.defaultExpectation = &StorageMockCreateReturnExpectation{}
	}

	if mmCreateReturn.defaultExpectation.params != nil {
		mmCreateReturn.mock.t.Fatalf("StorageMock.CreateReturn mock is already set by Expect")
	}

	if mmCreateReturn.defaultExpectation.paramPtrs == nil {
		mmCreateReturn.defaultExpectation.paramPtrs = &StorageMockCreateReturnParamPtrs{}
	}
	mmCreateReturn.defaultExpectation.paramPtrs.userID = &userID
	mmCreateReturn.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmCreateReturn
}

// ExpectOrderIDParam4 sets up expected param orderID for Storage.CreateReturn
func (mmCreateReturn *mStorageMockCreateReturn) ExpectOrderIDParam4(orderID int) *mStorageMockCreateReturn {
	if mmCreateReturn.mock.funcCreateReturn != nil {
		mmCreateReturn.mock.t.Fatalf("StorageMock.CreateReturn mock is already set by Set")
	}

	if mmCreateReturn.defaultExpectation == nil {
		mmCreateReturn.defaultExpectation = &StorageMockCreateReturnExpectation{}
	}

	if mmCreateReturn.defaultExpectation.params != nil {
		mmCreateReturn.mock.t.Fatalf("StorageMock.CreateReturn mock is already set by Expect")
	}

	if mmCreateReturn.defaultExpectation.paramPtrs == nil {
		mmCreateReturn.defaultExpectation.paramPtrs = &StorageMockCreateReturnParamPtrs{}
	}
	mmCreateReturn.defaultExpectation.paramPtrs.orderID = &orderID
	mmCreateReturn.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmCreateReturn
}

// Inspect accepts an inspector function that has same arguments as the Storage.CreateReturn
func (mmCreateReturn *mStorageMockCreateReturn) Inspect(f func(ctx context.Context, currentTime time.Time, userID int, orderID int)) *mStorageMockCreateReturn {
	if mmCreateReturn.mock.inspectFuncCreateReturn != nil {
		mmCreateReturn.mock.t.Fatalf("Inspect function is already set for StorageMock.CreateReturn")
	}

	mmCreateReturn.mock.inspectFuncCreateReturn = f

	return mmCreateReturn
}

// Return sets up results that will be returned by Storage.CreateReturn
func (mmCreateReturn *mStorageMockCreateReturn) Return(err error) *StorageMock {
	if mmCreateReturn.mock.funcCreateReturn != nil {
		mmCreateReturn.mock.t.Fatalf("StorageMock.CreateReturn mock is already set by Set")
	}

	if mmCreateReturn.defaultExpectation == nil {
		mmCreateReturn.defaultExpectation = &StorageMockCreateReturnExpectation{mock: mmCreateReturn.mock}
	}
	mmCreateReturn.defaultExpectation.results = &StorageMockCreateReturnResults{err}
	mmCreateReturn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateReturn.mock
}

// Set uses given function f to mock the Storage.CreateReturn method
func (mmCreateReturn *mStorageMockCreateReturn) Set(f func(ctx context.Context, currentTime time.Time, userID int, orderID int) (err error)) *StorageMock {
	if mmCreateReturn.defaultExpectation != nil {
		mmCreateReturn.mock.t.Fatalf("Default expectation is already set for the Storage.CreateReturn method")
	}

	if len(mmCreateReturn.expectations) > 0 {
		mmCreateReturn.mock.t.Fatalf("Some expectations are already set for the Storage.CreateReturn method")
	}

	mmCreateReturn.mock.funcCreateReturn = f
	mmCreateReturn.mock.funcCreateReturnOrigin = minimock.CallerInfo(1)
	return mmCreateReturn.mock
}

// When sets expectation for the Storage.CreateReturn which will trigger the result defined by the following
// Then helper
func (mmCreateReturn *mStorageMockCreateReturn) When(ctx context.Context, currentTime time.Time, userID int, orderID int) *StorageMockCreateReturnExpectation {
	if mmCreateReturn.mock.funcCreateReturn != nil {
		mmCreateReturn.mock.t.Fatalf("StorageMock.CreateReturn mock is already set by Set")
	}

	expectation := &StorageMockCreateReturnExpectation{
		mock:               mmCreateReturn.mock,
		params:             &StorageMockCreateReturnParams{ctx, currentTime, userID, orderID},
		expectationOrigins: StorageMockCreateReturnExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateReturn.expectations = append(mmCreateReturn.expectations, expectation)
	return expectation
}

// Then sets up Storage.CreateReturn return parameters for the expectation previously defined by the When method
func (e *StorageMockCreateReturnExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockCreateReturnResults{err}
	return e.mock
}

// Times sets number of times Storage.CreateReturn should be invoked
func (mmCreateReturn *mStorageMockCreateReturn) Times(n uint64) *mStorageMockCreateReturn {
	if n == 0 {
		mmCreateReturn.mock.t.Fatalf("Times of StorageMock.CreateReturn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateReturn.expectedInvocations, n)
	mmCreateReturn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateReturn
}

func (mmCreateReturn *mStorageMockCreateReturn) invocationsDone() bool {
	if len(mmCreateReturn.expectations) == 0 && mmCreateReturn.defaultExpectation == nil && mmCreateReturn.mock.funcCreateReturn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateReturn.mock.afterCreateReturnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateReturn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateReturn implements mm_usecase.Storage
func (mmCreateReturn *StorageMock) CreateReturn(ctx context.Context, currentTime time.Time, userID int, orderID int) (err error) {
	mm_atomic.AddUint64(&mmCreateReturn.beforeCreateReturnCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateReturn.afterCreateReturnCounter, 1)

	mmCreateReturn.t.Helper()

	if mmCreateReturn.inspectFuncCreateReturn != nil {
		mmCreateReturn.inspectFuncCreateReturn(ctx, currentTime, userID, orderID)
	}

	mm_params := StorageMockCreateReturnParams{ctx, currentTime, userID, orderID}

	// Record call args
	mmCreateReturn.CreateReturnMock.mutex.Lock()
	mmCreateReturn.CreateReturnMock.callArgs = append(mmCreateReturn.CreateReturnMock.callArgs, &mm_params)
	mmCreateReturn.CreateReturnMock.mutex.Unlock()

	for _, e := range mmCreateReturn.CreateReturnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateReturn.CreateReturnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateReturn.CreateReturnMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateReturn.CreateReturnMock.defaultExpectation.params
		mm_want_ptrs := mmCreateReturn.CreateReturnMock.defaultExpectation.paramPtrs

		mm_got := StorageMockCreateReturnParams{ctx, currentTime, userID, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateReturn.t.Errorf("StorageMock.CreateReturn got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateReturn.CreateReturnMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.currentTime != nil && !minimock.Equal(*mm_want_ptrs.currentTime, mm_got.currentTime) {
				mmCreateReturn.t.Errorf("StorageMock.CreateReturn got unexpected parameter currentTime, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateReturn.CreateReturnMock.defaultExpectation.expectationOrigins.originCurrentTime, *mm_want_ptrs.currentTime, mm_got.currentTime, minimock.Diff(*mm_want_ptrs.currentTime, mm_got.currentTime))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmCreateReturn.t.Errorf("StorageMock.CreateReturn got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateReturn.CreateReturnMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmCreateReturn.t.Errorf("StorageMock.CreateReturn got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateReturn.CreateReturnMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateReturn.t.Errorf("StorageMock.CreateReturn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateReturn.CreateReturnMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateReturn.CreateReturnMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateReturn.t.Fatal("No results are set for the StorageMock.CreateReturn")
		}
		return (*mm_results).err
	}
	if mmCreateReturn.funcCreateReturn != nil {
		return mmCreateReturn.funcCreateReturn(ctx, currentTime, userID, orderID)
	}
	mmCreateReturn.t.Fatalf("Unexpected call to StorageMock.CreateReturn. %v %v %v %v", ctx, currentTime, userID, orderID)
	return
}

// CreateReturnAfterCounter returns a count of finished StorageMock.CreateReturn invocations
func (mmCreateReturn *StorageMock) CreateReturnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateReturn.afterCreateReturnCounter)
}

// CreateReturnBeforeCounter returns a count of StorageMock.CreateReturn invocations
func (mmCreateReturn *StorageMock) CreateReturnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateReturn.beforeCreateReturnCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.CreateReturn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateReturn *mStorageMockCreateReturn) Calls() []*StorageMockCreateReturnParams {
	mmCreateReturn.mutex.RLock()

	argCopy := make([]*StorageMockCreateReturnParams, len(mmCreateReturn.callArgs))
	copy(argCopy, mmCreateReturn.callArgs)

	mmCreateReturn.mutex.RUnlock()

	return argCopy
}

// MinimockCreateReturnDone returns true if the count of the CreateReturn invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockCreateReturnDone() bool {
	if m.CreateReturnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateReturnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateReturnMock.invocationsDone()
}

// MinimockCreateReturnInspect logs each unmet expectation
func (m *StorageMock) MinimockCreateReturnInspect() {
	for _, e := range m.CreateReturnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.CreateReturn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateReturnCounter := mm_atomic.LoadUint64(&m.afterCreateReturnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateReturnMock.defaultExpectation != nil && afterCreateReturnCounter < 1 {
		if m.CreateReturnMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.CreateReturn at\n%s", m.CreateReturnMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.CreateReturn at\n%s with params: %#v", m.CreateReturnMock.defaultExpectation.expectationOrigins.origin, *m.CreateReturnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateReturn != nil && afterCreateReturnCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.CreateReturn at\n%s", m.funcCreateReturnOrigin)
	}

	if !m.CreateReturnMock.invocationsDone() && afterCreateReturnCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.CreateReturn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateReturnMock.expectedInvocations), m.CreateReturnMock.expectedInvocationsOrigin, afterCreateReturnCounter)
	}
}

type mStorageMockDeleteOrder struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockDeleteOrderExpectation
	expectations       []*StorageMockDeleteOrderExpectation

	callArgs []*StorageMockDeleteOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockDeleteOrderExpectation specifies expectation struct of the Storage.DeleteOrder
type StorageMockDeleteOrderExpectation struct {
	mock               *StorageMock
	params             *StorageMockDeleteOrderParams
	paramPtrs          *StorageMockDeleteOrderParamPtrs
	expectationOrigins StorageMockDeleteOrderExpectationOrigins
	results            *StorageMockDeleteOrderResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockDeleteOrderParams contains parameters of the Storage.DeleteOrder
type StorageMockDeleteOrderParams struct {
	ctx     context.Context
	orderID int
}

// StorageMockDeleteOrderParamPtrs contains pointers to parameters of the Storage.DeleteOrder
type StorageMockDeleteOrderParamPtrs struct {
	ctx     *context.Context
	orderID *int
}

// StorageMockDeleteOrderResults contains results of the Storage.DeleteOrder
type StorageMockDeleteOrderResults struct {
	err error
}

// StorageMockDeleteOrderOrigins contains origins of expectations of the Storage.DeleteOrder
type StorageMockDeleteOrderExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteOrder *mStorageMockDeleteOrder) Optional() *mStorageMockDeleteOrder {
	mmDeleteOrder.optional = true
	return mmDeleteOrder
}

// Expect sets up expected params for Storage.DeleteOrder
func (mmDeleteOrder *mStorageMockDeleteOrder) Expect(ctx context.Context, orderID int) *mStorageMockDeleteOrder {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("StorageMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &StorageMockDeleteOrderExpectation{}
	}

	if mmDeleteOrder.defaultExpectation.paramPtrs != nil {
		mmDeleteOrder.mock.t.Fatalf("StorageMock.DeleteOrder mock is already set by ExpectParams functions")
	}

	mmDeleteOrder.defaultExpectation.params = &StorageMockDeleteOrderParams{ctx, orderID}
	mmDeleteOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteOrder.expectations {
		if minimock.Equal(e.params, mmDeleteOrder.defaultExpectation.params) {
			mmDeleteOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteOrder.defaultExpectation.params)
		}
	}

	return mmDeleteOrder
}

// ExpectCtxParam1 sets up expected param ctx for Storage.DeleteOrder
func (mmDeleteOrder *mStorageMockDeleteOrder) ExpectCtxParam1(ctx context.Context) *mStorageMockDeleteOrder {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("StorageMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &StorageMockDeleteOrderExpectation{}
	}

	if mmDeleteOrder.defaultExpectation.params != nil {
		mmDeleteOrder.mock.t.Fatalf("StorageMock.DeleteOrder mock is already set by Expect")
	}

	if mmDeleteOrder.defaultExpectation.paramPtrs == nil {
		mmDeleteOrder.defaultExpectation.paramPtrs = &StorageMockDeleteOrderParamPtrs{}
	}
	mmDeleteOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteOrder
}

// ExpectOrderIDParam2 sets up expected param orderID for Storage.DeleteOrder
func (mmDeleteOrder *mStorageMockDeleteOrder) ExpectOrderIDParam2(orderID int) *mStorageMockDeleteOrder {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("StorageMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &StorageMockDeleteOrderExpectation{}
	}

	if mmDeleteOrder.defaultExpectation.params != nil {
		mmDeleteOrder.mock.t.Fatalf("StorageMock.DeleteOrder mock is already set by Expect")
	}

	if mmDeleteOrder.defaultExpectation.paramPtrs == nil {
		mmDeleteOrder.defaultExpectation.paramPtrs = &StorageMockDeleteOrderParamPtrs{}
	}
	mmDeleteOrder.defaultExpectation.paramPtrs.orderID = &orderID
	mmDeleteOrder.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmDeleteOrder
}

// Inspect accepts an inspector function that has same arguments as the Storage.DeleteOrder
func (mmDeleteOrder *mStorageMockDeleteOrder) Inspect(f func(ctx context.Context, orderID int)) *mStorageMockDeleteOrder {
	if mmDeleteOrder.mock.inspectFuncDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("Inspect function is already set for StorageMock.DeleteOrder")
	}

	mmDeleteOrder.mock.inspectFuncDeleteOrder = f

	return mmDeleteOrder
}

// Return sets up results that will be returned by Storage.DeleteOrder
func (mmDeleteOrder *mStorageMockDeleteOrder) Return(err error) *StorageMock {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("StorageMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &StorageMockDeleteOrderExpectation{mock: mmDeleteOrder.mock}
	}
	mmDeleteOrder.defaultExpectation.results = &StorageMockDeleteOrderResults{err}
	mmDeleteOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteOrder.mock
}

// Set uses given function f to mock the Storage.DeleteOrder method
func (mmDeleteOrder *mStorageMockDeleteOrder) Set(f func(ctx context.Context, orderID int) (err error)) *StorageMock {
	if mmDeleteOrder.defaultExpectation != nil {
		mmDeleteOrder.mock.t.Fatalf("Default expectation is already set for the Storage.DeleteOrder method")
	}

	if len(mmDeleteOrder.expectations) > 0 {
		mmDeleteOrder.mock.t.Fatalf("Some expectations are already set for the Storage.DeleteOrder method")
	}

	mmDeleteOrder.mock.funcDeleteOrder = f
	mmDeleteOrder.mock.funcDeleteOrderOrigin = minimock.CallerInfo(1)
	return mmDeleteOrder.mock
}

// When sets expectation for the Storage.DeleteOrder which will trigger the result defined by the following
// Then helper
func (mmDeleteOrder *mStorageMockDeleteOrder) When(ctx context.Context, orderID int) *StorageMockDeleteOrderExpectation {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("StorageMock.DeleteOrder mock is already set by Set")
	}

	expectation := &StorageMockDeleteOrderExpectation{
		mock:               mmDeleteOrder.mock,
		params:             &StorageMockDeleteOrderParams{ctx, orderID},
		expectationOrigins: StorageMockDeleteOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteOrder.expectations = append(mmDeleteOrder.expectations, expectation)
	return expectation
}

// Then sets up Storage.DeleteOrder return parameters for the expectation previously defined by the When method
func (e *StorageMockDeleteOrderExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockDeleteOrderResults{err}
	return e.mock
}

// Times sets number of times Storage.DeleteOrder should be invoked
func (mmDeleteOrder *mStorageMockDeleteOrder) Times(n uint64) *mStorageMockDeleteOrder {
	if n == 0 {
		mmDeleteOrder.mock.t.Fatalf("Times of StorageMock.DeleteOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteOrder.expectedInvocations, n)
	mmDeleteOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteOrder
}

func (mmDeleteOrder *mStorageMockDeleteOrder) invocationsDone() bool {
	if len(mmDeleteOrder.expectations) == 0 && mmDeleteOrder.defaultExpectation == nil && mmDeleteOrder.mock.funcDeleteOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteOrder.mock.afterDeleteOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteOrder implements mm_usecase.Storage
func (mmDeleteOrder *StorageMock) DeleteOrder(ctx context.Context, orderID int) (err error) {
	mm_atomic.AddUint64(&mmDeleteOrder.beforeDeleteOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteOrder.afterDeleteOrderCounter, 1)

	mmDeleteOrder.t.Helper()

	if mmDeleteOrder.inspectFuncDeleteOrder != nil {
		mmDeleteOrder.inspectFuncDeleteOrder(ctx, orderID)
	}

	mm_params := StorageMockDeleteOrderParams{ctx, orderID}

	// Record call args
	mmDeleteOrder.DeleteOrderMock.mutex.Lock()
	mmDeleteOrder.DeleteOrderMock.callArgs = append(mmDeleteOrder.DeleteOrderMock.callArgs, &mm_params)
	mmDeleteOrder.DeleteOrderMock.mutex.Unlock()

	for _, e := range mmDeleteOrder.DeleteOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteOrder.DeleteOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteOrder.DeleteOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteOrder.DeleteOrderMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteOrder.DeleteOrderMock.defaultExpectation.paramPtrs

		mm_got := StorageMockDeleteOrderParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteOrder.t.Errorf("StorageMock.DeleteOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteOrder.DeleteOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmDeleteOrder.t.Errorf("StorageMock.DeleteOrder got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteOrder.DeleteOrderMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteOrder.t.Errorf("StorageMock.DeleteOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteOrder.DeleteOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteOrder.DeleteOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteOrder.t.Fatal("No results are set for the StorageMock.DeleteOrder")
		}
		return (*mm_results).err
	}
	if mmDeleteOrder.funcDeleteOrder != nil {
		return mmDeleteOrder.funcDeleteOrder(ctx, orderID)
	}
	mmDeleteOrder.t.Fatalf("Unexpected call to StorageMock.DeleteOrder. %v %v", ctx, orderID)
	return
}

// DeleteOrderAfterCounter returns a count of finished StorageMock.DeleteOrder invocations
func (mmDeleteOrder *StorageMock) DeleteOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrder.afterDeleteOrderCounter)
}

// DeleteOrderBeforeCounter returns a count of StorageMock.DeleteOrder invocations
func (mmDeleteOrder *StorageMock) DeleteOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrder.beforeDeleteOrderCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.DeleteOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteOrder *mStorageMockDeleteOrder) Calls() []*StorageMockDeleteOrderParams {
	mmDeleteOrder.mutex.RLock()

	argCopy := make([]*StorageMockDeleteOrderParams, len(mmDeleteOrder.callArgs))
	copy(argCopy, mmDeleteOrder.callArgs)

	mmDeleteOrder.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteOrderDone returns true if the count of the DeleteOrder invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockDeleteOrderDone() bool {
	if m.DeleteOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteOrderMock.invocationsDone()
}

// MinimockDeleteOrderInspect logs each unmet expectation
func (m *StorageMock) MinimockDeleteOrderInspect() {
	for _, e := range m.DeleteOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.DeleteOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteOrderCounter := mm_atomic.LoadUint64(&m.afterDeleteOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteOrderMock.defaultExpectation != nil && afterDeleteOrderCounter < 1 {
		if m.DeleteOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.DeleteOrder at\n%s", m.DeleteOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.DeleteOrder at\n%s with params: %#v", m.DeleteOrderMock.defaultExpectation.expectationOrigins.origin, *m.DeleteOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteOrder != nil && afterDeleteOrderCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.DeleteOrder at\n%s", m.funcDeleteOrderOrigin)
	}

	if !m.DeleteOrderMock.invocationsDone() && afterDeleteOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.DeleteOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteOrderMock.expectedInvocations), m.DeleteOrderMock.expectedInvocationsOrigin, afterDeleteOrderCounter)
	}
}

type mStorageMockGetOrder struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetOrderExpectation
	expectations       []*StorageMockGetOrderExpectation

	callArgs []*StorageMockGetOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetOrderExpectation specifies expectation struct of the Storage.GetOrder
type StorageMockGetOrderExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetOrderParams
	paramPtrs          *StorageMockGetOrderParamPtrs
	expectationOrigins StorageMockGetOrderExpectationOrigins
	results            *StorageMockGetOrderResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetOrderParams contains parameters of the Storage.GetOrder
type StorageMockGetOrderParams struct {
	ctx     context.Context
	orderID int
	now     time.Time
}

// StorageMockGetOrderParamPtrs contains pointers to parameters of the Storage.GetOrder
type StorageMockGetOrderParamPtrs struct {
	ctx     *context.Context
	orderID *int
	now     *time.Time
}

// StorageMockGetOrderResults contains results of the Storage.GetOrder
type StorageMockGetOrderResults struct {
	o1  domain.Order
	err error
}

// StorageMockGetOrderOrigins contains origins of expectations of the Storage.GetOrder
type StorageMockGetOrderExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
	originNow     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrder *mStorageMockGetOrder) Optional() *mStorageMockGetOrder {
	mmGetOrder.optional = true
	return mmGetOrder
}

// Expect sets up expected params for Storage.GetOrder
func (mmGetOrder *mStorageMockGetOrder) Expect(ctx context.Context, orderID int, now time.Time) *mStorageMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("StorageMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &StorageMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.paramPtrs != nil {
		mmGetOrder.mock.t.Fatalf("StorageMock.GetOrder mock is already set by ExpectParams functions")
	}

	mmGetOrder.defaultExpectation.params = &StorageMockGetOrderParams{ctx, orderID, now}
	mmGetOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrder.expectations {
		if minimock.Equal(e.params, mmGetOrder.defaultExpectation.params) {
			mmGetOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrder.defaultExpectation.params)
		}
	}

	return mmGetOrder
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetOrder
func (mmGetOrder *mStorageMockGetOrder) ExpectCtxParam1(ctx context.Context) *mStorageMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("StorageMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &StorageMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.params != nil {
		mmGetOrder.mock.t.Fatalf("StorageMock.GetOrder mock is already set by Expect")
	}

	if mmGetOrder.defaultExpectation.paramPtrs == nil {
		mmGetOrder.defaultExpectation.paramPtrs = &StorageMockGetOrderParamPtrs{}
	}
	mmGetOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOrder
}

// ExpectOrderIDParam2 sets up expected param orderID for Storage.GetOrder
func (mmGetOrder *mStorageMockGetOrder) ExpectOrderIDParam2(orderID int) *mStorageMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("StorageMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &StorageMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.params != nil {
		mmGetOrder.mock.t.Fatalf("StorageMock.GetOrder mock is already set by Expect")
	}

	if mmGetOrder.defaultExpectation.paramPtrs == nil {
		mmGetOrder.defaultExpectation.paramPtrs = &StorageMockGetOrderParamPtrs{}
	}
	mmGetOrder.defaultExpectation.paramPtrs.orderID = &orderID
	mmGetOrder.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmGetOrder
}

// ExpectNowParam3 sets up expected param now for Storage.GetOrder
func (mmGetOrder *mStorageMockGetOrder) ExpectNowParam3(now time.Time) *mStorageMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("StorageMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &StorageMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.params != nil {
		mmGetOrder.mock.t.Fatalf("StorageMock.GetOrder mock is already set by Expect")
	}

	if mmGetOrder.defaultExpectation.paramPtrs == nil {
		mmGetOrder.defaultExpectation.paramPtrs = &StorageMockGetOrderParamPtrs{}
	}
	mmGetOrder.defaultExpectation.paramPtrs.now = &now
	mmGetOrder.defaultExpectation.expectationOrigins.originNow = minimock.CallerInfo(1)

	return mmGetOrder
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetOrder
func (mmGetOrder *mStorageMockGetOrder) Inspect(f func(ctx context.Context, orderID int, now time.Time)) *mStorageMockGetOrder {
	if mmGetOrder.mock.inspectFuncGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("Inspect function is already set for StorageMock.GetOrder")
	}

	mmGetOrder.mock.inspectFuncGetOrder = f

	return mmGetOrder
}

// Return sets up results that will be returned by Storage.GetOrder
func (mmGetOrder *mStorageMockGetOrder) Return(o1 domain.Order, err error) *StorageMock {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("StorageMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &StorageMockGetOrderExpectation{mock: mmGetOrder.mock}
	}
	mmGetOrder.defaultExpectation.results = &StorageMockGetOrderResults{o1, err}
	mmGetOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrder.mock
}

// Set uses given function f to mock the Storage.GetOrder method
func (mmGetOrder *mStorageMockGetOrder) Set(f func(ctx context.Context, orderID int, now time.Time) (o1 domain.Order, err error)) *StorageMock {
	if mmGetOrder.defaultExpectation != nil {
		mmGetOrder.mock.t.Fatalf("Default expectation is already set for the Storage.GetOrder method")
	}

	if len(mmGetOrder.expectations) > 0 {
		mmGetOrder.mock.t.Fatalf("Some expectations are already set for the Storage.GetOrder method")
	}

	mmGetOrder.mock.funcGetOrder = f
	mmGetOrder.mock.funcGetOrderOrigin = minimock.CallerInfo(1)
	return mmGetOrder.mock
}

// When sets expectation for the Storage.GetOrder which will trigger the result defined by the following
// Then helper
func (mmGetOrder *mStorageMockGetOrder) When(ctx context.Context, orderID int, now time.Time) *StorageMockGetOrderExpectation {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("StorageMock.GetOrder mock is already set by Set")
	}

	expectation := &StorageMockGetOrderExpectation{
		mock:               mmGetOrder.mock,
		params:             &StorageMockGetOrderParams{ctx, orderID, now},
		expectationOrigins: StorageMockGetOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrder.expectations = append(mmGetOrder.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetOrder return parameters for the expectation previously defined by the When method
func (e *StorageMockGetOrderExpectation) Then(o1 domain.Order, err error) *StorageMock {
	e.results = &StorageMockGetOrderResults{o1, err}
	return e.mock
}

// Times sets number of times Storage.GetOrder should be invoked
func (mmGetOrder *mStorageMockGetOrder) Times(n uint64) *mStorageMockGetOrder {
	if n == 0 {
		mmGetOrder.mock.t.Fatalf("Times of StorageMock.GetOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrder.expectedInvocations, n)
	mmGetOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrder
}

func (mmGetOrder *mStorageMockGetOrder) invocationsDone() bool {
	if len(mmGetOrder.expectations) == 0 && mmGetOrder.defaultExpectation == nil && mmGetOrder.mock.funcGetOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrder.mock.afterGetOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrder implements mm_usecase.Storage
func (mmGetOrder *StorageMock) GetOrder(ctx context.Context, orderID int, now time.Time) (o1 domain.Order, err error) {
	mm_atomic.AddUint64(&mmGetOrder.beforeGetOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrder.afterGetOrderCounter, 1)

	mmGetOrder.t.Helper()

	if mmGetOrder.inspectFuncGetOrder != nil {
		mmGetOrder.inspectFuncGetOrder(ctx, orderID, now)
	}

	mm_params := StorageMockGetOrderParams{ctx, orderID, now}

	// Record call args
	mmGetOrder.GetOrderMock.mutex.Lock()
	mmGetOrder.GetOrderMock.callArgs = append(mmGetOrder.GetOrderMock.callArgs, &mm_params)
	mmGetOrder.GetOrderMock.mutex.Unlock()

	for _, e := range mmGetOrder.GetOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmGetOrder.GetOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrder.GetOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrder.GetOrderMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrder.GetOrderMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetOrderParams{ctx, orderID, now}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrder.t.Errorf("StorageMock.GetOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetOrder.t.Errorf("StorageMock.GetOrder got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.now != nil && !minimock.Equal(*mm_want_ptrs.now, mm_got.now) {
				mmGetOrder.t.Errorf("StorageMock.GetOrder got unexpected parameter now, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.originNow, *mm_want_ptrs.now, mm_got.now, minimock.Diff(*mm_want_ptrs.now, mm_got.now))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrder.t.Errorf("StorageMock.GetOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrder.GetOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrder.t.Fatal("No results are set for the StorageMock.GetOrder")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmGetOrder.funcGetOrder != nil {
		return mmGetOrder.funcGetOrder(ctx, orderID, now)
	}
	mmGetOrder.t.Fatalf("Unexpected call to StorageMock.GetOrder. %v %v %v", ctx, orderID, now)
	return
}

// GetOrderAfterCounter returns a count of finished StorageMock.GetOrder invocations
func (mmGetOrder *StorageMock) GetOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.afterGetOrderCounter)
}

// GetOrderBeforeCounter returns a count of StorageMock.GetOrder invocations
func (mmGetOrder *StorageMock) GetOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.beforeGetOrderCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrder *mStorageMockGetOrder) Calls() []*StorageMockGetOrderParams {
	mmGetOrder.mutex.RLock()

	argCopy := make([]*StorageMockGetOrderParams, len(mmGetOrder.callArgs))
	copy(argCopy, mmGetOrder.callArgs)

	mmGetOrder.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderDone returns true if the count of the GetOrder invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetOrderDone() bool {
	if m.GetOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrderMock.invocationsDone()
}

// MinimockGetOrderInspect logs each unmet expectation
func (m *StorageMock) MinimockGetOrderInspect() {
	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrderCounter := mm_atomic.LoadUint64(&m.afterGetOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderMock.defaultExpectation != nil && afterGetOrderCounter < 1 {
		if m.GetOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetOrder at\n%s", m.GetOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetOrder at\n%s with params: %#v", m.GetOrderMock.defaultExpectation.expectationOrigins.origin, *m.GetOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrder != nil && afterGetOrderCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetOrder at\n%s", m.funcGetOrderOrigin)
	}

	if !m.GetOrderMock.invocationsDone() && afterGetOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrderMock.expectedInvocations), m.GetOrderMock.expectedInvocationsOrigin, afterGetOrderCounter)
	}
}

type mStorageMockGetOrders struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetOrdersExpectation
	expectations       []*StorageMockGetOrdersExpectation

	callArgs []*StorageMockGetOrdersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetOrdersExpectation specifies expectation struct of the Storage.GetOrders
type StorageMockGetOrdersExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetOrdersParams
	paramPtrs          *StorageMockGetOrdersParamPtrs
	expectationOrigins StorageMockGetOrdersExpectationOrigins
	results            *StorageMockGetOrdersResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetOrdersParams contains parameters of the Storage.GetOrders
type StorageMockGetOrdersParams struct {
	ctx      context.Context
	orderIDs []int
}

// StorageMockGetOrdersParamPtrs contains pointers to parameters of the Storage.GetOrders
type StorageMockGetOrdersParamPtrs struct {
	ctx      *context.Context
	orderIDs *[]int
}

// StorageMockGetOrdersResults contains results of the Storage.GetOrders
type StorageMockGetOrdersResults struct {
	oa1 []domain.Order
	err error
}

// StorageMockGetOrdersOrigins contains origins of expectations of the Storage.GetOrders
type StorageMockGetOrdersExpectationOrigins struct {
	origin         string
	originCtx      string
	originOrderIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrders *mStorageMockGetOrders) Optional() *mStorageMockGetOrders {
	mmGetOrders.optional = true
	return mmGetOrders
}

// Expect sets up expected params for Storage.GetOrders
func (mmGetOrders *mStorageMockGetOrders) Expect(ctx context.Context, orderIDs []int) *mStorageMockGetOrders {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("StorageMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &StorageMockGetOrdersExpectation{}
	}

	if mmGetOrders.defaultExpectation.paramPtrs != nil {
		mmGetOrders.mock.t.Fatalf("StorageMock.GetOrders mock is already set by ExpectParams functions")
	}

	mmGetOrders.defaultExpectation.params = &StorageMockGetOrdersParams{ctx, orderIDs}
	mmGetOrders.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrders.expectations {
		if minimock.Equal(e.params, mmGetOrders.defaultExpectation.params) {
			mmGetOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrders.defaultExpectation.params)
		}
	}

	return mmGetOrders
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetOrders
func (mmGetOrders *mStorageMockGetOrders) ExpectCtxParam1(ctx context.Context) *mStorageMockGetOrders {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("StorageMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &StorageMockGetOrdersExpectation{}
	}

	if mmGetOrders.defaultExpectation.params != nil {
		mmGetOrders.mock.t.Fatalf("StorageMock.GetOrders mock is already set by Expect")
	}

	if mmGetOrders.defaultExpectation.paramPtrs == nil {
		mmGetOrders.defaultExpectation.paramPtrs = &StorageMockGetOrdersParamPtrs{}
	}
	mmGetOrders.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOrders.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOrders
}

// ExpectOrderIDsParam2 sets up expected param orderIDs for Storage.GetOrders
func (mmGetOrders *mStorageMockGetOrders) ExpectOrderIDsParam2(orderIDs []int) *mStorageMockGetOrders {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("StorageMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &StorageMockGetOrdersExpectation{}
	}

	if mmGetOrders.defaultExpectation.params != nil {
		mmGetOrders.mock.t.Fatalf("StorageMock.GetOrders mock is already set by Expect")
	}

	if mmGetOrders.defaultExpectation.paramPtrs == nil {
		mmGetOrders.defaultExpectation.paramPtrs = &StorageMockGetOrdersParamPtrs{}
	}
	mmGetOrders.defaultExpectation.paramPtrs.orderIDs = &orderIDs
	mmGetOrders.defaultExpectation.expectationOrigins.originOrderIDs = minimock.CallerInfo(1)

	return mmGetOrders
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetOrders
func (mmGetOrders *mStorageMockGetOrders) Inspect(f func(ctx context.Context, orderIDs []int)) *mStorageMockGetOrders {
	if mmGetOrders.mock.inspectFuncGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("Inspect function is already set for StorageMock.GetOrders")
	}

	mmGetOrders.mock.inspectFuncGetOrders = f

	return mmGetOrders
}

// Return sets up results that will be returned by Storage.GetOrders
func (mmGetOrders *mStorageMockGetOrders) Return(oa1 []domain.Order, err error) *StorageMock {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("StorageMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &StorageMockGetOrdersExpectation{mock: mmGetOrders.mock}
	}
	mmGetOrders.defaultExpectation.results = &StorageMockGetOrdersResults{oa1, err}
	mmGetOrders.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrders.mock
}

// Set uses given function f to mock the Storage.GetOrders method
func (mmGetOrders *mStorageMockGetOrders) Set(f func(ctx context.Context, orderIDs []int) (oa1 []domain.Order, err error)) *StorageMock {
	if mmGetOrders.defaultExpectation != nil {
		mmGetOrders.mock.t.Fatalf("Default expectation is already set for the Storage.GetOrders method")
	}

	if len(mmGetOrders.expectations) > 0 {
		mmGetOrders.mock.t.Fatalf("Some expectations are already set for the Storage.GetOrders method")
	}

	mmGetOrders.mock.funcGetOrders = f
	mmGetOrders.mock.funcGetOrdersOrigin = minimock.CallerInfo(1)
	return mmGetOrders.mock
}

// When sets expectation for the Storage.GetOrders which will trigger the result defined by the following
// Then helper
func (mmGetOrders *mStorageMockGetOrders) When(ctx context.Context, orderIDs []int) *StorageMockGetOrdersExpectation {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("StorageMock.GetOrders mock is already set by Set")
	}

	expectation := &StorageMockGetOrdersExpectation{
		mock:               mmGetOrders.mock,
		params:             &StorageMockGetOrdersParams{ctx, orderIDs},
		expectationOrigins: StorageMockGetOrdersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrders.expectations = append(mmGetOrders.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetOrders return parameters for the expectation previously defined by the When method
func (e *StorageMockGetOrdersExpectation) Then(oa1 []domain.Order, err error) *StorageMock {
	e.results = &StorageMockGetOrdersResults{oa1, err}
	return e.mock
}

// Times sets number of times Storage.GetOrders should be invoked
func (mmGetOrders *mStorageMockGetOrders) Times(n uint64) *mStorageMockGetOrders {
	if n == 0 {
		mmGetOrders.mock.t.Fatalf("Times of StorageMock.GetOrders mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrders.expectedInvocations, n)
	mmGetOrders.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrders
}

func (mmGetOrders *mStorageMockGetOrders) invocationsDone() bool {
	if len(mmGetOrders.expectations) == 0 && mmGetOrders.defaultExpectation == nil && mmGetOrders.mock.funcGetOrders == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrders.mock.afterGetOrdersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrders.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrders implements mm_usecase.Storage
func (mmGetOrders *StorageMock) GetOrders(ctx context.Context, orderIDs []int) (oa1 []domain.Order, err error) {
	mm_atomic.AddUint64(&mmGetOrders.beforeGetOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrders.afterGetOrdersCounter, 1)

	mmGetOrders.t.Helper()

	if mmGetOrders.inspectFuncGetOrders != nil {
		mmGetOrders.inspectFuncGetOrders(ctx, orderIDs)
	}

	mm_params := StorageMockGetOrdersParams{ctx, orderIDs}

	// Record call args
	mmGetOrders.GetOrdersMock.mutex.Lock()
	mmGetOrders.GetOrdersMock.callArgs = append(mmGetOrders.GetOrdersMock.callArgs, &mm_params)
	mmGetOrders.GetOrdersMock.mutex.Unlock()

	for _, e := range mmGetOrders.GetOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmGetOrders.GetOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrders.GetOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrders.GetOrdersMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrders.GetOrdersMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetOrdersParams{ctx, orderIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrders.t.Errorf("StorageMock.GetOrders got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrders.GetOrdersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderIDs != nil && !minimock.Equal(*mm_want_ptrs.orderIDs, mm_got.orderIDs) {
				mmGetOrders.t.Errorf("StorageMock.GetOrders got unexpected parameter orderIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrders.GetOrdersMock.defaultExpectation.expectationOrigins.originOrderIDs, *mm_want_ptrs.orderIDs, mm_got.orderIDs, minimock.Diff(*mm_want_ptrs.orderIDs, mm_got.orderIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrders.t.Errorf("StorageMock.GetOrders got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrders.GetOrdersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrders.GetOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrders.t.Fatal("No results are set for the StorageMock.GetOrders")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmGetOrders.funcGetOrders != nil {
		return mmGetOrders.funcGetOrders(ctx, orderIDs)
	}
	mmGetOrders.t.Fatalf("Unexpected call to StorageMock.GetOrders. %v %v", ctx, orderIDs)
	return
}

// GetOrdersAfterCounter returns a count of finished StorageMock.GetOrders invocations
func (mmGetOrders *StorageMock) GetOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrders.afterGetOrdersCounter)
}

// GetOrdersBeforeCounter returns a count of StorageMock.GetOrders invocations
func (mmGetOrders *StorageMock) GetOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrders.beforeGetOrdersCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrders *mStorageMockGetOrders) Calls() []*StorageMockGetOrdersParams {
	mmGetOrders.mutex.RLock()

	argCopy := make([]*StorageMockGetOrdersParams, len(mmGetOrders.callArgs))
	copy(argCopy, mmGetOrders.callArgs)

	mmGetOrders.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrdersDone returns true if the count of the GetOrders invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetOrdersDone() bool {
	if m.GetOrdersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrdersMock.invocationsDone()
}

// MinimockGetOrdersInspect logs each unmet expectation
func (m *StorageMock) MinimockGetOrdersInspect() {
	for _, e := range m.GetOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetOrders at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrdersCounter := mm_atomic.LoadUint64(&m.afterGetOrdersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrdersMock.defaultExpectation != nil && afterGetOrdersCounter < 1 {
		if m.GetOrdersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetOrders at\n%s", m.GetOrdersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetOrders at\n%s with params: %#v", m.GetOrdersMock.defaultExpectation.expectationOrigins.origin, *m.GetOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrders != nil && afterGetOrdersCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetOrders at\n%s", m.funcGetOrdersOrigin)
	}

	if !m.GetOrdersMock.invocationsDone() && afterGetOrdersCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetOrders at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrdersMock.expectedInvocations), m.GetOrdersMock.expectedInvocationsOrigin, afterGetOrdersCounter)
	}
}

type mStorageMockGetOrdersByUserID struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetOrdersByUserIDExpectation
	expectations       []*StorageMockGetOrdersByUserIDExpectation

	callArgs []*StorageMockGetOrdersByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetOrdersByUserIDExpectation specifies expectation struct of the Storage.GetOrdersByUserID
type StorageMockGetOrdersByUserIDExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetOrdersByUserIDParams
	paramPtrs          *StorageMockGetOrdersByUserIDParamPtrs
	expectationOrigins StorageMockGetOrdersByUserIDExpectationOrigins
	results            *StorageMockGetOrdersByUserIDResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetOrdersByUserIDParams contains parameters of the Storage.GetOrdersByUserID
type StorageMockGetOrdersByUserIDParams struct {
	ctx    context.Context
	userID int
	lastN  int
}

// StorageMockGetOrdersByUserIDParamPtrs contains pointers to parameters of the Storage.GetOrdersByUserID
type StorageMockGetOrdersByUserIDParamPtrs struct {
	ctx    *context.Context
	userID *int
	lastN  *int
}

// StorageMockGetOrdersByUserIDResults contains results of the Storage.GetOrdersByUserID
type StorageMockGetOrdersByUserIDResults struct {
	oa1 []domain.Order
	err error
}

// StorageMockGetOrdersByUserIDOrigins contains origins of expectations of the Storage.GetOrdersByUserID
type StorageMockGetOrdersByUserIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originLastN  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrdersByUserID *mStorageMockGetOrdersByUserID) Optional() *mStorageMockGetOrdersByUserID {
	mmGetOrdersByUserID.optional = true
	return mmGetOrdersByUserID
}

// Expect sets up expected params for Storage.GetOrdersByUserID
func (mmGetOrdersByUserID *mStorageMockGetOrdersByUserID) Expect(ctx context.Context, userID int, lastN int) *mStorageMockGetOrdersByUserID {
	if mmGetOrdersByUserID.mock.funcGetOrdersByUserID != nil {
		mmGetOrdersByUserID.mock.t.Fatalf("StorageMock.GetOrdersByUserID mock is already set by Set")
	}

	if mmGetOrdersByUserID.defaultExpectation == nil {
		mmGetOrdersByUserID.defaultExpectation = &StorageMockGetOrdersByUserIDExpectation{}
	}

	if mmGetOrdersByUserID.defaultExpectation.paramPtrs != nil {
		mmGetOrdersByUserID.mock.t.Fatalf("StorageMock.GetOrdersByUserID mock is already set by ExpectParams functions")
	}

	mmGetOrdersByUserID.defaultExpectation.params = &StorageMockGetOrdersByUserIDParams{ctx, userID, lastN}
	mmGetOrdersByUserID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrdersByUserID.expectations {
		if minimock.Equal(e.params, mmGetOrdersByUserID.defaultExpectation.params) {
			mmGetOrdersByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrdersByUserID.defaultExpectation.params)
		}
	}

	return mmGetOrdersByUserID
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetOrdersByUserID
func (mmGetOrdersByUserID *mStorageMockGetOrdersByUserID) ExpectCtxParam1(ctx context.Context) *mStorageMockGetOrdersByUserID {
	if mmGetOrdersByUserID.mock.funcGetOrdersByUserID != nil {
		mmGetOrdersByUserID.mock.t.Fatalf("StorageMock.GetOrdersByUserID mock is already set by Set")
	}

	if mmGetOrdersByUserID.defaultExpectation == nil {
		mmGetOrdersByUserID.defaultExpectation = &StorageMockGetOrdersByUserIDExpectation{}
	}

	if mmGetOrdersByUserID.defaultExpectation.params != nil {
		mmGetOrdersByUserID.mock.t.Fatalf("StorageMock.GetOrdersByUserID mock is already set by Expect")
	}

	if mmGetOrdersByUserID.defaultExpectation.paramPtrs == nil {
		mmGetOrdersByUserID.defaultExpectation.paramPtrs = &StorageMockGetOrdersByUserIDParamPtrs{}
	}
	mmGetOrdersByUserID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOrdersByUserID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOrdersByUserID
}

// ExpectUserIDParam2 sets up expected param userID for Storage.GetOrdersByUserID
func (mmGetOrdersByUserID *mStorageMockGetOrdersByUserID) ExpectUserIDParam2(userID int) *mStorageMockGetOrdersByUserID {
	if mmGetOrdersByUserID.mock.funcGetOrdersByUserID != nil {
		mmGetOrdersByUserID.mock.t.Fatalf("StorageMock.GetOrdersByUserID mock is already set by Set")
	}

	if mmGetOrdersByUserID.defaultExpectation == nil {
		mmGetOrdersByUserID.defaultExpectation = &StorageMockGetOrdersByUserIDExpectation{}
	}

	if mmGetOrdersByUserID.defaultExpectation.params != nil {
		mmGetOrdersByUserID.mock.t.Fatalf("StorageMock.GetOrdersByUserID mock is already set by Expect")
	}

	if mmGetOrdersByUserID.defaultExpectation.paramPtrs == nil {
		mmGetOrdersByUserID.defaultExpectation.paramPtrs = &StorageMockGetOrdersByUserIDParamPtrs{}
	}
	mmGetOrdersByUserID.defaultExpectation.paramPtrs.userID = &userID
	mmGetOrdersByUserID.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetOrdersByUserID
}

// ExpectLastNParam3 sets up expected param lastN for Storage.GetOrdersByUserID
func (mmGetOrdersByUserID *mStorageMockGetOrdersByUserID) ExpectLastNParam3(lastN int) *mStorageMockGetOrdersByUserID {
	if mmGetOrdersByUserID.mock.funcGetOrdersByUserID != nil {
		mmGetOrdersByUserID.mock.t.Fatalf("StorageMock.GetOrdersByUserID mock is already set by Set")
	}

	if mmGetOrdersByUserID.defaultExpectation == nil {
		mmGetOrdersByUserID.defaultExpectation = &StorageMockGetOrdersByUserIDExpectation{}
	}

	if mmGetOrdersByUserID.defaultExpectation.params != nil {
		mmGetOrdersByUserID.mock.t.Fatalf("StorageMock.GetOrdersByUserID mock is already set by Expect")
	}

	if mmGetOrdersByUserID.defaultExpectation.paramPtrs == nil {
		mmGetOrdersByUserID.defaultExpectation.paramPtrs = &StorageMockGetOrdersByUserIDParamPtrs{}
	}
	mmGetOrdersByUserID.defaultExpectation.paramPtrs.lastN = &lastN
	mmGetOrdersByUserID.defaultExpectation.expectationOrigins.originLastN = minimock.CallerInfo(1)

	return mmGetOrdersByUserID
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetOrdersByUserID
func (mmGetOrdersByUserID *mStorageMockGetOrdersByUserID) Inspect(f func(ctx context.Context, userID int, lastN int)) *mStorageMockGetOrdersByUserID {
	if mmGetOrdersByUserID.mock.inspectFuncGetOrdersByUserID != nil {
		mmGetOrdersByUserID.mock.t.Fatalf("Inspect function is already set for StorageMock.GetOrdersByUserID")
	}

	mmGetOrdersByUserID.mock.inspectFuncGetOrdersByUserID = f

	return mmGetOrdersByUserID
}

// Return sets up results that will be returned by Storage.GetOrdersByUserID
func (mmGetOrdersByUserID *mStorageMockGetOrdersByUserID) Return(oa1 []domain.Order, err error) *StorageMock {
	if mmGetOrdersByUserID.mock.funcGetOrdersByUserID != nil {
		mmGetOrdersByUserID.mock.t.Fatalf("StorageMock.GetOrdersByUserID mock is already set by Set")
	}

	if mmGetOrdersByUserID.defaultExpectation == nil {
		mmGetOrdersByUserID.defaultExpectation = &StorageMockGetOrdersByUserIDExpectation{mock: mmGetOrdersByUserID.mock}
	}
	mmGetOrdersByUserID.defaultExpectation.results = &StorageMockGetOrdersByUserIDResults{oa1, err}
	mmGetOrdersByUserID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrdersByUserID.mock
}

// Set uses given function f to mock the Storage.GetOrdersByUserID method
func (mmGetOrdersByUserID *mStorageMockGetOrdersByUserID) Set(f func(ctx context.Context, userID int, lastN int) (oa1 []domain.Order, err error)) *StorageMock {
	if mmGetOrdersByUserID.defaultExpectation != nil {
		mmGetOrdersByUserID.mock.t.Fatalf("Default expectation is already set for the Storage.GetOrdersByUserID method")
	}

	if len(mmGetOrdersByUserID.expectations) > 0 {
		mmGetOrdersByUserID.mock.t.Fatalf("Some expectations are already set for the Storage.GetOrdersByUserID method")
	}

	mmGetOrdersByUserID.mock.funcGetOrdersByUserID = f
	mmGetOrdersByUserID.mock.funcGetOrdersByUserIDOrigin = minimock.CallerInfo(1)
	return mmGetOrdersByUserID.mock
}

// When sets expectation for the Storage.GetOrdersByUserID which will trigger the result defined by the following
// Then helper
func (mmGetOrdersByUserID *mStorageMockGetOrdersByUserID) When(ctx context.Context, userID int, lastN int) *StorageMockGetOrdersByUserIDExpectation {
	if mmGetOrdersByUserID.mock.funcGetOrdersByUserID != nil {
		mmGetOrdersByUserID.mock.t.Fatalf("StorageMock.GetOrdersByUserID mock is already set by Set")
	}

	expectation := &StorageMockGetOrdersByUserIDExpectation{
		mock:               mmGetOrdersByUserID.mock,
		params:             &StorageMockGetOrdersByUserIDParams{ctx, userID, lastN},
		expectationOrigins: StorageMockGetOrdersByUserIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrdersByUserID.expectations = append(mmGetOrdersByUserID.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetOrdersByUserID return parameters for the expectation previously defined by the When method
func (e *StorageMockGetOrdersByUserIDExpectation) Then(oa1 []domain.Order, err error) *StorageMock {
	e.results = &StorageMockGetOrdersByUserIDResults{oa1, err}
	return e.mock
}

// Times sets number of times Storage.GetOrdersByUserID should be invoked
func (mmGetOrdersByUserID *mStorageMockGetOrdersByUserID) Times(n uint64) *mStorageMockGetOrdersByUserID {
	if n == 0 {
		mmGetOrdersByUserID.mock.t.Fatalf("Times of StorageMock.GetOrdersByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrdersByUserID.expectedInvocations, n)
	mmGetOrdersByUserID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrdersByUserID
}

func (mmGetOrdersByUserID *mStorageMockGetOrdersByUserID) invocationsDone() bool {
	if len(mmGetOrdersByUserID.expectations) == 0 && mmGetOrdersByUserID.defaultExpectation == nil && mmGetOrdersByUserID.mock.funcGetOrdersByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrdersByUserID.mock.afterGetOrdersByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrdersByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrdersByUserID implements mm_usecase.Storage
func (mmGetOrdersByUserID *StorageMock) GetOrdersByUserID(ctx context.Context, userID int, lastN int) (oa1 []domain.Order, err error) {
	mm_atomic.AddUint64(&mmGetOrdersByUserID.beforeGetOrdersByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrdersByUserID.afterGetOrdersByUserIDCounter, 1)

	mmGetOrdersByUserID.t.Helper()

	if mmGetOrdersByUserID.inspectFuncGetOrdersByUserID != nil {
		mmGetOrdersByUserID.inspectFuncGetOrdersByUserID(ctx, userID, lastN)
	}

	mm_params := StorageMockGetOrdersByUserIDParams{ctx, userID, lastN}

	// Record call args
	mmGetOrdersByUserID.GetOrdersByUserIDMock.mutex.Lock()
	mmGetOrdersByUserID.GetOrdersByUserIDMock.callArgs = append(mmGetOrdersByUserID.GetOrdersByUserIDMock.callArgs, &mm_params)
	mmGetOrdersByUserID.GetOrdersByUserIDMock.mutex.Unlock()

	for _, e := range mmGetOrdersByUserID.GetOrdersByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmGetOrdersByUserID.GetOrdersByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrdersByUserID.GetOrdersByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrdersByUserID.GetOrdersByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrdersByUserID.GetOrdersByUserIDMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetOrdersByUserIDParams{ctx, userID, lastN}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrdersByUserID.t.Errorf("StorageMock.GetOrdersByUserID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrdersByUserID.GetOrdersByUserIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetOrdersByUserID.t.Errorf("StorageMock.GetOrdersByUserID got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrdersByUserID.GetOrdersByUserIDMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.lastN != nil && !minimock.Equal(*mm_want_ptrs.lastN, mm_got.lastN) {
				mmGetOrdersByUserID.t.Errorf("StorageMock.GetOrdersByUserID got unexpected parameter lastN, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrdersByUserID.GetOrdersByUserIDMock.defaultExpectation.expectationOrigins.originLastN, *mm_want_ptrs.lastN, mm_got.lastN, minimock.Diff(*mm_want_ptrs.lastN, mm_got.lastN))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrdersByUserID.t.Errorf("StorageMock.GetOrdersByUserID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrdersByUserID.GetOrdersByUserIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrdersByUserID.GetOrdersByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrdersByUserID.t.Fatal("No results are set for the StorageMock.GetOrdersByUserID")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmGetOrdersByUserID.funcGetOrdersByUserID != nil {
		return mmGetOrdersByUserID.funcGetOrdersByUserID(ctx, userID, lastN)
	}
	mmGetOrdersByUserID.t.Fatalf("Unexpected call to StorageMock.GetOrdersByUserID. %v %v %v", ctx, userID, lastN)
	return
}

// GetOrdersByUserIDAfterCounter returns a count of finished StorageMock.GetOrdersByUserID invocations
func (mmGetOrdersByUserID *StorageMock) GetOrdersByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrdersByUserID.afterGetOrdersByUserIDCounter)
}

// GetOrdersByUserIDBeforeCounter returns a count of StorageMock.GetOrdersByUserID invocations
func (mmGetOrdersByUserID *StorageMock) GetOrdersByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrdersByUserID.beforeGetOrdersByUserIDCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetOrdersByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrdersByUserID *mStorageMockGetOrdersByUserID) Calls() []*StorageMockGetOrdersByUserIDParams {
	mmGetOrdersByUserID.mutex.RLock()

	argCopy := make([]*StorageMockGetOrdersByUserIDParams, len(mmGetOrdersByUserID.callArgs))
	copy(argCopy, mmGetOrdersByUserID.callArgs)

	mmGetOrdersByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrdersByUserIDDone returns true if the count of the GetOrdersByUserID invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetOrdersByUserIDDone() bool {
	if m.GetOrdersByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrdersByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrdersByUserIDMock.invocationsDone()
}

// MinimockGetOrdersByUserIDInspect logs each unmet expectation
func (m *StorageMock) MinimockGetOrdersByUserIDInspect() {
	for _, e := range m.GetOrdersByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetOrdersByUserID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrdersByUserIDCounter := mm_atomic.LoadUint64(&m.afterGetOrdersByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrdersByUserIDMock.defaultExpectation != nil && afterGetOrdersByUserIDCounter < 1 {
		if m.GetOrdersByUserIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetOrdersByUserID at\n%s", m.GetOrdersByUserIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetOrdersByUserID at\n%s with params: %#v", m.GetOrdersByUserIDMock.defaultExpectation.expectationOrigins.origin, *m.GetOrdersByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrdersByUserID != nil && afterGetOrdersByUserIDCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetOrdersByUserID at\n%s", m.funcGetOrdersByUserIDOrigin)
	}

	if !m.GetOrdersByUserIDMock.invocationsDone() && afterGetOrdersByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetOrdersByUserID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrdersByUserIDMock.expectedInvocations), m.GetOrdersByUserIDMock.expectedInvocationsOrigin, afterGetOrdersByUserIDCounter)
	}
}

type mStorageMockGetReturn struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetReturnExpectation
	expectations       []*StorageMockGetReturnExpectation

	callArgs []*StorageMockGetReturnParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetReturnExpectation specifies expectation struct of the Storage.GetReturn
type StorageMockGetReturnExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetReturnParams
	paramPtrs          *StorageMockGetReturnParamPtrs
	expectationOrigins StorageMockGetReturnExpectationOrigins
	results            *StorageMockGetReturnResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetReturnParams contains parameters of the Storage.GetReturn
type StorageMockGetReturnParams struct {
	ctx     context.Context
	orderID int
	now     time.Time
}

// StorageMockGetReturnParamPtrs contains pointers to parameters of the Storage.GetReturn
type StorageMockGetReturnParamPtrs struct {
	ctx     *context.Context
	orderID *int
	now     *time.Time
}

// StorageMockGetReturnResults contains results of the Storage.GetReturn
type StorageMockGetReturnResults struct {
	o1  domain.OrderReturn
	err error
}

// StorageMockGetReturnOrigins contains origins of expectations of the Storage.GetReturn
type StorageMockGetReturnExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
	originNow     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReturn *mStorageMockGetReturn) Optional() *mStorageMockGetReturn {
	mmGetReturn.optional = true
	return mmGetReturn
}

// Expect sets up expected params for Storage.GetReturn
func (mmGetReturn *mStorageMockGetReturn) Expect(ctx context.Context, orderID int, now time.Time) *mStorageMockGetReturn {
	if mmGetReturn.mock.funcGetReturn != nil {
		mmGetReturn.mock.t.Fatalf("StorageMock.GetReturn mock is already set by Set")
	}

	if mmGetReturn.defaultExpectation == nil {
		mmGetReturn.defaultExpectation = &StorageMockGetReturnExpectation{}
	}

	if mmGetReturn.defaultExpectation.paramPtrs != nil {
		mmGetReturn.mock.t.Fatalf("StorageMock.GetReturn mock is already set by ExpectParams functions")
	}

	mmGetReturn.defaultExpectation.params = &StorageMockGetReturnParams{ctx, orderID, now}
	mmGetReturn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetReturn.expectations {
		if minimock.Equal(e.params, mmGetReturn.defaultExpectation.params) {
			mmGetReturn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReturn.defaultExpectation.params)
		}
	}

	return mmGetReturn
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetReturn
func (mmGetReturn *mStorageMockGetReturn) ExpectCtxParam1(ctx context.Context) *mStorageMockGetReturn {
	if mmGetReturn.mock.funcGetReturn != nil {
		mmGetReturn.mock.t.Fatalf("StorageMock.GetReturn mock is already set by Set")
	}

	if mmGetReturn.defaultExpectation == nil {
		mmGetReturn.defaultExpectation = &StorageMockGetReturnExpectation{}
	}

	if mmGetReturn.defaultExpectation.params != nil {
		mmGetReturn.mock.t.Fatalf("StorageMock.GetReturn mock is already set by Expect")
	}

	if mmGetReturn.defaultExpectation.paramPtrs == nil {
		mmGetReturn.defaultExpectation.paramPtrs = &StorageMockGetReturnParamPtrs{}
	}
	mmGetReturn.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetReturn.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetReturn
}

// ExpectOrderIDParam2 sets up expected param orderID for Storage.GetReturn
func (mmGetReturn *mStorageMockGetReturn) ExpectOrderIDParam2(orderID int) *mStorageMockGetReturn {
	if mmGetReturn.mock.funcGetReturn != nil {
		mmGetReturn.mock.t.Fatalf("StorageMock.GetReturn mock is already set by Set")
	}

	if mmGetReturn.defaultExpectation == nil {
		mmGetReturn.defaultExpectation = &StorageMockGetReturnExpectation{}
	}

	if mmGetReturn.defaultExpectation.params != nil {
		mmGetReturn.mock.t.Fatalf("StorageMock.GetReturn mock is already set by Expect")
	}

	if mmGetReturn.defaultExpectation.paramPtrs == nil {
		mmGetReturn.defaultExpectation.paramPtrs = &StorageMockGetReturnParamPtrs{}
	}
	mmGetReturn.defaultExpectation.paramPtrs.orderID = &orderID
	mmGetReturn.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmGetReturn
}

// ExpectNowParam3 sets up expected param now for Storage.GetReturn
func (mmGetReturn *mStorageMockGetReturn) ExpectNowParam3(now time.Time) *mStorageMockGetReturn {
	if mmGetReturn.mock.funcGetReturn != nil {
		mmGetReturn.mock.t.Fatalf("StorageMock.GetReturn mock is already set by Set")
	}

	if mmGetReturn.defaultExpectation == nil {
		mmGetReturn.defaultExpectation = &StorageMockGetReturnExpectation{}
	}

	if mmGetReturn.defaultExpectation.params != nil {
		mmGetReturn.mock.t.Fatalf("StorageMock.GetReturn mock is already set by Expect")
	}

	if mmGetReturn.defaultExpectation.paramPtrs == nil {
		mmGetReturn.defaultExpectation.paramPtrs = &StorageMockGetReturnParamPtrs{}
	}
	mmGetReturn.defaultExpectation.paramPtrs.now = &now
	mmGetReturn.defaultExpectation.expectationOrigins.originNow = minimock.CallerInfo(1)

	return mmGetReturn
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetReturn
func (mmGetReturn *mStorageMockGetReturn) Inspect(f func(ctx context.Context, orderID int, now time.Time)) *mStorageMockGetReturn {
	if mmGetReturn.mock.inspectFuncGetReturn != nil {
		mmGetReturn.mock.t.Fatalf("Inspect function is already set for StorageMock.GetReturn")
	}

	mmGetReturn.mock.inspectFuncGetReturn = f

	return mmGetReturn
}

// Return sets up results that will be returned by Storage.GetReturn
func (mmGetReturn *mStorageMockGetReturn) Return(o1 domain.OrderReturn, err error) *StorageMock {
	if mmGetReturn.mock.funcGetReturn != nil {
		mmGetReturn.mock.t.Fatalf("StorageMock.GetReturn mock is already set by Set")
	}

	if mmGetReturn.defaultExpectation == nil {
		mmGetReturn.defaultExpectation = &StorageMockGetReturnExpectation{mock: mmGetReturn.mock}
	}
	mmGetReturn.defaultExpectation.results = &StorageMockGetReturnResults{o1, err}
	mmGetReturn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetReturn.mock
}

// Set uses given function f to mock the Storage.GetReturn method
func (mmGetReturn *mStorageMockGetReturn) Set(f func(ctx context.Context, orderID int, now time.Time) (o1 domain.OrderReturn, err error)) *StorageMock {
	if mmGetReturn.defaultExpectation != nil {
		mmGetReturn.mock.t.Fatalf("Default expectation is already set for the Storage.GetReturn method")
	}

	if len(mmGetReturn.expectations) > 0 {
		mmGetReturn.mock.t.Fatalf("Some expectations are already set for the Storage.GetReturn method")
	}

	mmGetReturn.mock.funcGetReturn = f
	mmGetReturn.mock.funcGetReturnOrigin = minimock.CallerInfo(1)
	return mmGetReturn.mock
}

// When sets expectation for the Storage.GetReturn which will trigger the result defined by the following
// Then helper
func (mmGetReturn *mStorageMockGetReturn) When(ctx context.Context, orderID int, now time.Time) *StorageMockGetReturnExpectation {
	if mmGetReturn.mock.funcGetReturn != nil {
		mmGetReturn.mock.t.Fatalf("StorageMock.GetReturn mock is already set by Set")
	}

	expectation := &StorageMockGetReturnExpectation{
		mock:               mmGetReturn.mock,
		params:             &StorageMockGetReturnParams{ctx, orderID, now},
		expectationOrigins: StorageMockGetReturnExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetReturn.expectations = append(mmGetReturn.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetReturn return parameters for the expectation previously defined by the When method
func (e *StorageMockGetReturnExpectation) Then(o1 domain.OrderReturn, err error) *StorageMock {
	e.results = &StorageMockGetReturnResults{o1, err}
	return e.mock
}

// Times sets number of times Storage.GetReturn should be invoked
func (mmGetReturn *mStorageMockGetReturn) Times(n uint64) *mStorageMockGetReturn {
	if n == 0 {
		mmGetReturn.mock.t.Fatalf("Times of StorageMock.GetReturn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetReturn.expectedInvocations, n)
	mmGetReturn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetReturn
}

func (mmGetReturn *mStorageMockGetReturn) invocationsDone() bool {
	if len(mmGetReturn.expectations) == 0 && mmGetReturn.defaultExpectation == nil && mmGetReturn.mock.funcGetReturn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetReturn.mock.afterGetReturnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetReturn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetReturn implements mm_usecase.Storage
func (mmGetReturn *StorageMock) GetReturn(ctx context.Context, orderID int, now time.Time) (o1 domain.OrderReturn, err error) {
	mm_atomic.AddUint64(&mmGetReturn.beforeGetReturnCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReturn.afterGetReturnCounter, 1)

	mmGetReturn.t.Helper()

	if mmGetReturn.inspectFuncGetReturn != nil {
		mmGetReturn.inspectFuncGetReturn(ctx, orderID, now)
	}

	mm_params := StorageMockGetReturnParams{ctx, orderID, now}

	// Record call args
	mmGetReturn.GetReturnMock.mutex.Lock()
	mmGetReturn.GetReturnMock.callArgs = append(mmGetReturn.GetReturnMock.callArgs, &mm_params)
	mmGetReturn.GetReturnMock.mutex.Unlock()

	for _, e := range mmGetReturn.GetReturnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmGetReturn.GetReturnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReturn.GetReturnMock.defaultExpectation.Counter, 1)
		mm_want := mmGetReturn.GetReturnMock.defaultExpectation.params
		mm_want_ptrs := mmGetReturn.GetReturnMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetReturnParams{ctx, orderID, now}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetReturn.t.Errorf("StorageMock.GetReturn got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReturn.GetReturnMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetReturn.t.Errorf("StorageMock.GetReturn got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReturn.GetReturnMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.now != nil && !minimock.Equal(*mm_want_ptrs.now, mm_got.now) {
				mmGetReturn.t.Errorf("StorageMock.GetReturn got unexpected parameter now, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReturn.GetReturnMock.defaultExpectation.expectationOrigins.originNow, *mm_want_ptrs.now, mm_got.now, minimock.Diff(*mm_want_ptrs.now, mm_got.now))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetReturn.t.Errorf("StorageMock.GetReturn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetReturn.GetReturnMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetReturn.GetReturnMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReturn.t.Fatal("No results are set for the StorageMock.GetReturn")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmGetReturn.funcGetReturn != nil {
		return mmGetReturn.funcGetReturn(ctx, orderID, now)
	}
	mmGetReturn.t.Fatalf("Unexpected call to StorageMock.GetReturn. %v %v %v", ctx, orderID, now)
	return
}

// GetReturnAfterCounter returns a count of finished StorageMock.GetReturn invocations
func (mmGetReturn *StorageMock) GetReturnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReturn.afterGetReturnCounter)
}

// GetReturnBeforeCounter returns a count of StorageMock.GetReturn invocations
func (mmGetReturn *StorageMock) GetReturnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReturn.beforeGetReturnCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetReturn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReturn *mStorageMockGetReturn) Calls() []*StorageMockGetReturnParams {
	mmGetReturn.mutex.RLock()

	argCopy := make([]*StorageMockGetReturnParams, len(mmGetReturn.callArgs))
	copy(argCopy, mmGetReturn.callArgs)

	mmGetReturn.mutex.RUnlock()

	return argCopy
}

// MinimockGetReturnDone returns true if the count of the GetReturn invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetReturnDone() bool {
	if m.GetReturnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetReturnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetReturnMock.invocationsDone()
}

// MinimockGetReturnInspect logs each unmet expectation
func (m *StorageMock) MinimockGetReturnInspect() {
	for _, e := range m.GetReturnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetReturn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetReturnCounter := mm_atomic.LoadUint64(&m.afterGetReturnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetReturnMock.defaultExpectation != nil && afterGetReturnCounter < 1 {
		if m.GetReturnMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetReturn at\n%s", m.GetReturnMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetReturn at\n%s with params: %#v", m.GetReturnMock.defaultExpectation.expectationOrigins.origin, *m.GetReturnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReturn != nil && afterGetReturnCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetReturn at\n%s", m.funcGetReturnOrigin)
	}

	if !m.GetReturnMock.invocationsDone() && afterGetReturnCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetReturn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetReturnMock.expectedInvocations), m.GetReturnMock.expectedInvocationsOrigin, afterGetReturnCounter)
	}
}

type mStorageMockGetReturns struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetReturnsExpectation
	expectations       []*StorageMockGetReturnsExpectation

	callArgs []*StorageMockGetReturnsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetReturnsExpectation specifies expectation struct of the Storage.GetReturns
type StorageMockGetReturnsExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetReturnsParams
	paramPtrs          *StorageMockGetReturnsParamPtrs
	expectationOrigins StorageMockGetReturnsExpectationOrigins
	results            *StorageMockGetReturnsResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetReturnsParams contains parameters of the Storage.GetReturns
type StorageMockGetReturnsParams struct {
	ctx      context.Context
	page     int
	pageSize int
}

// StorageMockGetReturnsParamPtrs contains pointers to parameters of the Storage.GetReturns
type StorageMockGetReturnsParamPtrs struct {
	ctx      *context.Context
	page     *int
	pageSize *int
}

// StorageMockGetReturnsResults contains results of the Storage.GetReturns
type StorageMockGetReturnsResults struct {
	oa1 []domain.OrderReturn
	err error
}

// StorageMockGetReturnsOrigins contains origins of expectations of the Storage.GetReturns
type StorageMockGetReturnsExpectationOrigins struct {
	origin         string
	originCtx      string
	originPage     string
	originPageSize string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReturns *mStorageMockGetReturns) Optional() *mStorageMockGetReturns {
	mmGetReturns.optional = true
	return mmGetReturns
}

// Expect sets up expected params for Storage.GetReturns
func (mmGetReturns *mStorageMockGetReturns) Expect(ctx context.Context, page int, pageSize int) *mStorageMockGetReturns {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("StorageMock.GetReturns mock is already set by Set")
	}

	if mmGetReturns.defaultExpectation == nil {
		mmGetReturns.defaultExpectation = &StorageMockGetReturnsExpectation{}
	}

	if mmGetReturns.defaultExpectation.paramPtrs != nil {
		mmGetReturns.mock.t.Fatalf("StorageMock.GetReturns mock is already set by ExpectParams functions")
	}

	mmGetReturns.defaultExpectation.params = &StorageMockGetReturnsParams{ctx, page, pageSize}
	mmGetReturns.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetReturns.expectations {
		if minimock.Equal(e.params, mmGetReturns.defaultExpectation.params) {
			mmGetReturns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReturns.defaultExpectation.params)
		}
	}

	return mmGetReturns
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetReturns
func (mmGetReturns *mStorageMockGetReturns) ExpectCtxParam1(ctx context.Context) *mStorageMockGetReturns {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("StorageMock.GetReturns mock is already set by Set")
	}

	if mmGetReturns.defaultExpectation == nil {
		mmGetReturns.defaultExpectation = &StorageMockGetReturnsExpectation{}
	}

	if mmGetReturns.defaultExpectation.params != nil {
		mmGetReturns.mock.t.Fatalf("StorageMock.GetReturns mock is already set by Expect")
	}

	if mmGetReturns.defaultExpectation.paramPtrs == nil {
		mmGetReturns.defaultExpectation.paramPtrs = &StorageMockGetReturnsParamPtrs{}
	}
	mmGetReturns.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetReturns.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetReturns
}

// ExpectPageParam2 sets up expected param page for Storage.GetReturns
func (mmGetReturns *mStorageMockGetReturns) ExpectPageParam2(page int) *mStorageMockGetReturns {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("StorageMock.GetReturns mock is already set by Set")
	}

	if mmGetReturns.defaultExpectation == nil {
		mmGetReturns.defaultExpectation = &StorageMockGetReturnsExpectation{}
	}

	if mmGetReturns.defaultExpectation.params != nil {
		mmGetReturns.mock.t.Fatalf("StorageMock.GetReturns mock is already set by Expect")
	}

	if mmGetReturns.defaultExpectation.paramPtrs == nil {
		mmGetReturns.defaultExpectation.paramPtrs = &StorageMockGetReturnsParamPtrs{}
	}
	mmGetReturns.defaultExpectation.paramPtrs.page = &page
	mmGetReturns.defaultExpectation.expectationOrigins.originPage = minimock.CallerInfo(1)

	return mmGetReturns
}

// ExpectPageSizeParam3 sets up expected param pageSize for Storage.GetReturns
func (mmGetReturns *mStorageMockGetReturns) ExpectPageSizeParam3(pageSize int) *mStorageMockGetReturns {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("StorageMock.GetReturns mock is already set by Set")
	}

	if mmGetReturns.defaultExpectation == nil {
		mmGetReturns.defaultExpectation = &StorageMockGetReturnsExpectation{}
	}

	if mmGetReturns.defaultExpectation.params != nil {
		mmGetReturns.mock.t.Fatalf("StorageMock.GetReturns mock is already set by Expect")
	}

	if mmGetReturns.defaultExpectation.paramPtrs == nil {
		mmGetReturns.defaultExpectation.paramPtrs = &StorageMockGetReturnsParamPtrs{}
	}
	mmGetReturns.defaultExpectation.paramPtrs.pageSize = &pageSize
	mmGetReturns.defaultExpectation.expectationOrigins.originPageSize = minimock.CallerInfo(1)

	return mmGetReturns
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetReturns
func (mmGetReturns *mStorageMockGetReturns) Inspect(f func(ctx context.Context, page int, pageSize int)) *mStorageMockGetReturns {
	if mmGetReturns.mock.inspectFuncGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("Inspect function is already set for StorageMock.GetReturns")
	}

	mmGetReturns.mock.inspectFuncGetReturns = f

	return mmGetReturns
}

// Return sets up results that will be returned by Storage.GetReturns
func (mmGetReturns *mStorageMockGetReturns) Return(oa1 []domain.OrderReturn, err error) *StorageMock {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("StorageMock.GetReturns mock is already set by Set")
	}

	if mmGetReturns.defaultExpectation == nil {
		mmGetReturns.defaultExpectation = &StorageMockGetReturnsExpectation{mock: mmGetReturns.mock}
	}
	mmGetReturns.defaultExpectation.results = &StorageMockGetReturnsResults{oa1, err}
	mmGetReturns.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetReturns.mock
}

// Set uses given function f to mock the Storage.GetReturns method
func (mmGetReturns *mStorageMockGetReturns) Set(f func(ctx context.Context, page int, pageSize int) (oa1 []domain.OrderReturn, err error)) *StorageMock {
	if mmGetReturns.defaultExpectation != nil {
		mmGetReturns.mock.t.Fatalf("Default expectation is already set for the Storage.GetReturns method")
	}

	if len(mmGetReturns.expectations) > 0 {
		mmGetReturns.mock.t.Fatalf("Some expectations are already set for the Storage.GetReturns method")
	}

	mmGetReturns.mock.funcGetReturns = f
	mmGetReturns.mock.funcGetReturnsOrigin = minimock.CallerInfo(1)
	return mmGetReturns.mock
}

// When sets expectation for the Storage.GetReturns which will trigger the result defined by the following
// Then helper
func (mmGetReturns *mStorageMockGetReturns) When(ctx context.Context, page int, pageSize int) *StorageMockGetReturnsExpectation {
	if mmGetReturns.mock.funcGetReturns != nil {
		mmGetReturns.mock.t.Fatalf("StorageMock.GetReturns mock is already set by Set")
	}

	expectation := &StorageMockGetReturnsExpectation{
		mock:               mmGetReturns.mock,
		params:             &StorageMockGetReturnsParams{ctx, page, pageSize},
		expectationOrigins: StorageMockGetReturnsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetReturns.expectations = append(mmGetReturns.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetReturns return parameters for the expectation previously defined by the When method
func (e *StorageMockGetReturnsExpectation) Then(oa1 []domain.OrderReturn, err error) *StorageMock {
	e.results = &StorageMockGetReturnsResults{oa1, err}
	return e.mock
}

// Times sets number of times Storage.GetReturns should be invoked
func (mmGetReturns *mStorageMockGetReturns) Times(n uint64) *mStorageMockGetReturns {
	if n == 0 {
		mmGetReturns.mock.t.Fatalf("Times of StorageMock.GetReturns mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetReturns.expectedInvocations, n)
	mmGetReturns.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetReturns
}

func (mmGetReturns *mStorageMockGetReturns) invocationsDone() bool {
	if len(mmGetReturns.expectations) == 0 && mmGetReturns.defaultExpectation == nil && mmGetReturns.mock.funcGetReturns == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetReturns.mock.afterGetReturnsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetReturns.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetReturns implements mm_usecase.Storage
func (mmGetReturns *StorageMock) GetReturns(ctx context.Context, page int, pageSize int) (oa1 []domain.OrderReturn, err error) {
	mm_atomic.AddUint64(&mmGetReturns.beforeGetReturnsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReturns.afterGetReturnsCounter, 1)

	mmGetReturns.t.Helper()

	if mmGetReturns.inspectFuncGetReturns != nil {
		mmGetReturns.inspectFuncGetReturns(ctx, page, pageSize)
	}

	mm_params := StorageMockGetReturnsParams{ctx, page, pageSize}

	// Record call args
	mmGetReturns.GetReturnsMock.mutex.Lock()
	mmGetReturns.GetReturnsMock.callArgs = append(mmGetReturns.GetReturnsMock.callArgs, &mm_params)
	mmGetReturns.GetReturnsMock.mutex.Unlock()

	for _, e := range mmGetReturns.GetReturnsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmGetReturns.GetReturnsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReturns.GetReturnsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetReturns.GetReturnsMock.defaultExpectation.params
		mm_want_ptrs := mmGetReturns.GetReturnsMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetReturnsParams{ctx, page, pageSize}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetReturns.t.Errorf("StorageMock.GetReturns got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReturns.GetReturnsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.page != nil && !minimock.Equal(*mm_want_ptrs.page, mm_got.page) {
				mmGetReturns.t.Errorf("StorageMock.GetReturns got unexpected parameter page, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReturns.GetReturnsMock.defaultExpectation.expectationOrigins.originPage, *mm_want_ptrs.page, mm_got.page, minimock.Diff(*mm_want_ptrs.page, mm_got.page))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmGetReturns.t.Errorf("StorageMock.GetReturns got unexpected parameter pageSize, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReturns.GetReturnsMock.defaultExpectation.expectationOrigins.originPageSize, *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetReturns.t.Errorf("StorageMock.GetReturns got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetReturns.GetReturnsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetReturns.GetReturnsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReturns.t.Fatal("No results are set for the StorageMock.GetReturns")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmGetReturns.funcGetReturns != nil {
		return mmGetReturns.funcGetReturns(ctx, page, pageSize)
	}
	mmGetReturns.t.Fatalf("Unexpected call to StorageMock.GetReturns. %v %v %v", ctx, page, pageSize)
	return
}

// GetReturnsAfterCounter returns a count of finished StorageMock.GetReturns invocations
func (mmGetReturns *StorageMock) GetReturnsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReturns.afterGetReturnsCounter)
}

// GetReturnsBeforeCounter returns a count of StorageMock.GetReturns invocations
func (mmGetReturns *StorageMock) GetReturnsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReturns.beforeGetReturnsCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetReturns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReturns *mStorageMockGetReturns) Calls() []*StorageMockGetReturnsParams {
	mmGetReturns.mutex.RLock()

	argCopy := make([]*StorageMockGetReturnsParams, len(mmGetReturns.callArgs))
	copy(argCopy, mmGetReturns.callArgs)

	mmGetReturns.mutex.RUnlock()

	return argCopy
}

// MinimockGetReturnsDone returns true if the count of the GetReturns invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetReturnsDone() bool {
	if m.GetReturnsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetReturnsMock.invocationsDone()
}

// MinimockGetReturnsInspect logs each unmet expectation
func (m *StorageMock) MinimockGetReturnsInspect() {
	for _, e := range m.GetReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetReturns at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetReturnsCounter := mm_atomic.LoadUint64(&m.afterGetReturnsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetReturnsMock.defaultExpectation != nil && afterGetReturnsCounter < 1 {
		if m.GetReturnsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetReturns at\n%s", m.GetReturnsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetReturns at\n%s with params: %#v", m.GetReturnsMock.defaultExpectation.expectationOrigins.origin, *m.GetReturnsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReturns != nil && afterGetReturnsCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetReturns at\n%s", m.funcGetReturnsOrigin)
	}

	if !m.GetReturnsMock.invocationsDone() && afterGetReturnsCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetReturns at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetReturnsMock.expectedInvocations), m.GetReturnsMock.expectedInvocationsOrigin, afterGetReturnsCounter)
	}
}

type mStorageMockUpdateReceiveDates struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockUpdateReceiveDatesExpectation
	expectations       []*StorageMockUpdateReceiveDatesExpectation

	callArgs []*StorageMockUpdateReceiveDatesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockUpdateReceiveDatesExpectation specifies expectation struct of the Storage.UpdateReceiveDates
type StorageMockUpdateReceiveDatesExpectation struct {
	mock               *StorageMock
	params             *StorageMockUpdateReceiveDatesParams
	paramPtrs          *StorageMockUpdateReceiveDatesParamPtrs
	expectationOrigins StorageMockUpdateReceiveDatesExpectationOrigins
	results            *StorageMockUpdateReceiveDatesResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockUpdateReceiveDatesParams contains parameters of the Storage.UpdateReceiveDates
type StorageMockUpdateReceiveDatesParams struct {
	ctx         context.Context
	currentTime time.Time
	orderIDs    []int
}

// StorageMockUpdateReceiveDatesParamPtrs contains pointers to parameters of the Storage.UpdateReceiveDates
type StorageMockUpdateReceiveDatesParamPtrs struct {
	ctx         *context.Context
	currentTime *time.Time
	orderIDs    *[]int
}

// StorageMockUpdateReceiveDatesResults contains results of the Storage.UpdateReceiveDates
type StorageMockUpdateReceiveDatesResults struct {
	err error
}

// StorageMockUpdateReceiveDatesOrigins contains origins of expectations of the Storage.UpdateReceiveDates
type StorageMockUpdateReceiveDatesExpectationOrigins struct {
	origin            string
	originCtx         string
	originCurrentTime string
	originOrderIDs    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateReceiveDates *mStorageMockUpdateReceiveDates) Optional() *mStorageMockUpdateReceiveDates {
	mmUpdateReceiveDates.optional = true
	return mmUpdateReceiveDates
}

// Expect sets up expected params for Storage.UpdateReceiveDates
func (mmUpdateReceiveDates *mStorageMockUpdateReceiveDates) Expect(ctx context.Context, currentTime time.Time, orderIDs []int) *mStorageMockUpdateReceiveDates {
	if mmUpdateReceiveDates.mock.funcUpdateReceiveDates != nil {
		mmUpdateReceiveDates.mock.t.Fatalf("StorageMock.UpdateReceiveDates mock is already set by Set")
	}

	if mmUpdateReceiveDates.defaultExpectation == nil {
		mmUpdateReceiveDates.defaultExpectation = &StorageMockUpdateReceiveDatesExpectation{}
	}

	if mmUpdateReceiveDates.defaultExpectation.paramPtrs != nil {
		mmUpdateReceiveDates.mock.t.Fatalf("StorageMock.UpdateReceiveDates mock is already set by ExpectParams functions")
	}

	mmUpdateReceiveDates.defaultExpectation.params = &StorageMockUpdateReceiveDatesParams{ctx, currentTime, orderIDs}
	mmUpdateReceiveDates.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateReceiveDates.expectations {
		if minimock.Equal(e.params, mmUpdateReceiveDates.defaultExpectation.params) {
			mmUpdateReceiveDates.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateReceiveDates.defaultExpectation.params)
		}
	}

	return mmUpdateReceiveDates
}

// ExpectCtxParam1 sets up expected param ctx for Storage.UpdateReceiveDates
func (mmUpdateReceiveDates *mStorageMockUpdateReceiveDates) ExpectCtxParam1(ctx context.Context) *mStorageMockUpdateReceiveDates {
	if mmUpdateReceiveDates.mock.funcUpdateReceiveDates != nil {
		mmUpdateReceiveDates.mock.t.Fatalf("StorageMock.UpdateReceiveDates mock is already set by Set")
	}

	if mmUpdateReceiveDates.defaultExpectation == nil {
		mmUpdateReceiveDates.defaultExpectation = &StorageMockUpdateReceiveDatesExpectation{}
	}

	if mmUpdateReceiveDates.defaultExpectation.params != nil {
		mmUpdateReceiveDates.mock.t.Fatalf("StorageMock.UpdateReceiveDates mock is already set by Expect")
	}

	if mmUpdateReceiveDates.defaultExpectation.paramPtrs == nil {
		mmUpdateReceiveDates.defaultExpectation.paramPtrs = &StorageMockUpdateReceiveDatesParamPtrs{}
	}
	mmUpdateReceiveDates.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateReceiveDates.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateReceiveDates
}

// ExpectCurrentTimeParam2 sets up expected param currentTime for Storage.UpdateReceiveDates
func (mmUpdateReceiveDates *mStorageMockUpdateReceiveDates) ExpectCurrentTimeParam2(currentTime time.Time) *mStorageMockUpdateReceiveDates {
	if mmUpdateReceiveDates.mock.funcUpdateReceiveDates != nil {
		mmUpdateReceiveDates.mock.t.Fatalf("StorageMock.UpdateReceiveDates mock is already set by Set")
	}

	if mmUpdateReceiveDates.defaultExpectation == nil {
		mmUpdateReceiveDates.defaultExpectation = &StorageMockUpdateReceiveDatesExpectation{}
	}

	if mmUpdateReceiveDates.defaultExpectation.params != nil {
		mmUpdateReceiveDates.mock.t.Fatalf("StorageMock.UpdateReceiveDates mock is already set by Expect")
	}

	if mmUpdateReceiveDates.defaultExpectation.paramPtrs == nil {
		mmUpdateReceiveDates.defaultExpectation.paramPtrs = &StorageMockUpdateReceiveDatesParamPtrs{}
	}
	mmUpdateReceiveDates.defaultExpectation.paramPtrs.currentTime = &currentTime
	mmUpdateReceiveDates.defaultExpectation.expectationOrigins.originCurrentTime = minimock.CallerInfo(1)

	return mmUpdateReceiveDates
}

// ExpectOrderIDsParam3 sets up expected param orderIDs for Storage.UpdateReceiveDates
func (mmUpdateReceiveDates *mStorageMockUpdateReceiveDates) ExpectOrderIDsParam3(orderIDs []int) *mStorageMockUpdateReceiveDates {
	if mmUpdateReceiveDates.mock.funcUpdateReceiveDates != nil {
		mmUpdateReceiveDates.mock.t.Fatalf("StorageMock.UpdateReceiveDates mock is already set by Set")
	}

	if mmUpdateReceiveDates.defaultExpectation == nil {
		mmUpdateReceiveDates.defaultExpectation = &StorageMockUpdateReceiveDatesExpectation{}
	}

	if mmUpdateReceiveDates.defaultExpectation.params != nil {
		mmUpdateReceiveDates.mock.t.Fatalf("StorageMock.UpdateReceiveDates mock is already set by Expect")
	}

	if mmUpdateReceiveDates.defaultExpectation.paramPtrs == nil {
		mmUpdateReceiveDates.defaultExpectation.paramPtrs = &StorageMockUpdateReceiveDatesParamPtrs{}
	}
	mmUpdateReceiveDates.defaultExpectation.paramPtrs.orderIDs = &orderIDs
	mmUpdateReceiveDates.defaultExpectation.expectationOrigins.originOrderIDs = minimock.CallerInfo(1)

	return mmUpdateReceiveDates
}

// Inspect accepts an inspector function that has same arguments as the Storage.UpdateReceiveDates
func (mmUpdateReceiveDates *mStorageMockUpdateReceiveDates) Inspect(f func(ctx context.Context, currentTime time.Time, orderIDs []int)) *mStorageMockUpdateReceiveDates {
	if mmUpdateReceiveDates.mock.inspectFuncUpdateReceiveDates != nil {
		mmUpdateReceiveDates.mock.t.Fatalf("Inspect function is already set for StorageMock.UpdateReceiveDates")
	}

	mmUpdateReceiveDates.mock.inspectFuncUpdateReceiveDates = f

	return mmUpdateReceiveDates
}

// Return sets up results that will be returned by Storage.UpdateReceiveDates
func (mmUpdateReceiveDates *mStorageMockUpdateReceiveDates) Return(err error) *StorageMock {
	if mmUpdateReceiveDates.mock.funcUpdateReceiveDates != nil {
		mmUpdateReceiveDates.mock.t.Fatalf("StorageMock.UpdateReceiveDates mock is already set by Set")
	}

	if mmUpdateReceiveDates.defaultExpectation == nil {
		mmUpdateReceiveDates.defaultExpectation = &StorageMockUpdateReceiveDatesExpectation{mock: mmUpdateReceiveDates.mock}
	}
	mmUpdateReceiveDates.defaultExpectation.results = &StorageMockUpdateReceiveDatesResults{err}
	mmUpdateReceiveDates.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateReceiveDates.mock
}

// Set uses given function f to mock the Storage.UpdateReceiveDates method
func (mmUpdateReceiveDates *mStorageMockUpdateReceiveDates) Set(f func(ctx context.Context, currentTime time.Time, orderIDs []int) (err error)) *StorageMock {
	if mmUpdateReceiveDates.defaultExpectation != nil {
		mmUpdateReceiveDates.mock.t.Fatalf("Default expectation is already set for the Storage.UpdateReceiveDates method")
	}

	if len(mmUpdateReceiveDates.expectations) > 0 {
		mmUpdateReceiveDates.mock.t.Fatalf("Some expectations are already set for the Storage.UpdateReceiveDates method")
	}

	mmUpdateReceiveDates.mock.funcUpdateReceiveDates = f
	mmUpdateReceiveDates.mock.funcUpdateReceiveDatesOrigin = minimock.CallerInfo(1)
	return mmUpdateReceiveDates.mock
}

// When sets expectation for the Storage.UpdateReceiveDates which will trigger the result defined by the following
// Then helper
func (mmUpdateReceiveDates *mStorageMockUpdateReceiveDates) When(ctx context.Context, currentTime time.Time, orderIDs []int) *StorageMockUpdateReceiveDatesExpectation {
	if mmUpdateReceiveDates.mock.funcUpdateReceiveDates != nil {
		mmUpdateReceiveDates.mock.t.Fatalf("StorageMock.UpdateReceiveDates mock is already set by Set")
	}

	expectation := &StorageMockUpdateReceiveDatesExpectation{
		mock:               mmUpdateReceiveDates.mock,
		params:             &StorageMockUpdateReceiveDatesParams{ctx, currentTime, orderIDs},
		expectationOrigins: StorageMockUpdateReceiveDatesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateReceiveDates.expectations = append(mmUpdateReceiveDates.expectations, expectation)
	return expectation
}

// Then sets up Storage.UpdateReceiveDates return parameters for the expectation previously defined by the When method
func (e *StorageMockUpdateReceiveDatesExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockUpdateReceiveDatesResults{err}
	return e.mock
}

// Times sets number of times Storage.UpdateReceiveDates should be invoked
func (mmUpdateReceiveDates *mStorageMockUpdateReceiveDates) Times(n uint64) *mStorageMockUpdateReceiveDates {
	if n == 0 {
		mmUpdateReceiveDates.mock.t.Fatalf("Times of StorageMock.UpdateReceiveDates mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateReceiveDates.expectedInvocations, n)
	mmUpdateReceiveDates.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateReceiveDates
}

func (mmUpdateReceiveDates *mStorageMockUpdateReceiveDates) invocationsDone() bool {
	if len(mmUpdateReceiveDates.expectations) == 0 && mmUpdateReceiveDates.defaultExpectation == nil && mmUpdateReceiveDates.mock.funcUpdateReceiveDates == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateReceiveDates.mock.afterUpdateReceiveDatesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateReceiveDates.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateReceiveDates implements mm_usecase.Storage
func (mmUpdateReceiveDates *StorageMock) UpdateReceiveDates(ctx context.Context, currentTime time.Time, orderIDs []int) (err error) {
	mm_atomic.AddUint64(&mmUpdateReceiveDates.beforeUpdateReceiveDatesCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateReceiveDates.afterUpdateReceiveDatesCounter, 1)

	mmUpdateReceiveDates.t.Helper()

	if mmUpdateReceiveDates.inspectFuncUpdateReceiveDates != nil {
		mmUpdateReceiveDates.inspectFuncUpdateReceiveDates(ctx, currentTime, orderIDs)
	}

	mm_params := StorageMockUpdateReceiveDatesParams{ctx, currentTime, orderIDs}

	// Record call args
	mmUpdateReceiveDates.UpdateReceiveDatesMock.mutex.Lock()
	mmUpdateReceiveDates.UpdateReceiveDatesMock.callArgs = append(mmUpdateReceiveDates.UpdateReceiveDatesMock.callArgs, &mm_params)
	mmUpdateReceiveDates.UpdateReceiveDatesMock.mutex.Unlock()

	for _, e := range mmUpdateReceiveDates.UpdateReceiveDatesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateReceiveDates.UpdateReceiveDatesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateReceiveDates.UpdateReceiveDatesMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateReceiveDates.UpdateReceiveDatesMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateReceiveDates.UpdateReceiveDatesMock.defaultExpectation.paramPtrs

		mm_got := StorageMockUpdateReceiveDatesParams{ctx, currentTime, orderIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateReceiveDates.t.Errorf("StorageMock.UpdateReceiveDates got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateReceiveDates.UpdateReceiveDatesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.currentTime != nil && !minimock.Equal(*mm_want_ptrs.currentTime, mm_got.currentTime) {
				mmUpdateReceiveDates.t.Errorf("StorageMock.UpdateReceiveDates got unexpected parameter currentTime, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateReceiveDates.UpdateReceiveDatesMock.defaultExpectation.expectationOrigins.originCurrentTime, *mm_want_ptrs.currentTime, mm_got.currentTime, minimock.Diff(*mm_want_ptrs.currentTime, mm_got.currentTime))
			}

			if mm_want_ptrs.orderIDs != nil && !minimock.Equal(*mm_want_ptrs.orderIDs, mm_got.orderIDs) {
				mmUpdateReceiveDates.t.Errorf("StorageMock.UpdateReceiveDates got unexpected parameter orderIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateReceiveDates.UpdateReceiveDatesMock.defaultExpectation.expectationOrigins.originOrderIDs, *mm_want_ptrs.orderIDs, mm_got.orderIDs, minimock.Diff(*mm_want_ptrs.orderIDs, mm_got.orderIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateReceiveDates.t.Errorf("StorageMock.UpdateReceiveDates got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateReceiveDates.UpdateReceiveDatesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateReceiveDates.UpdateReceiveDatesMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateReceiveDates.t.Fatal("No results are set for the StorageMock.UpdateReceiveDates")
		}
		return (*mm_results).err
	}
	if mmUpdateReceiveDates.funcUpdateReceiveDates != nil {
		return mmUpdateReceiveDates.funcUpdateReceiveDates(ctx, currentTime, orderIDs)
	}
	mmUpdateReceiveDates.t.Fatalf("Unexpected call to StorageMock.UpdateReceiveDates. %v %v %v", ctx, currentTime, orderIDs)
	return
}

// UpdateReceiveDatesAfterCounter returns a count of finished StorageMock.UpdateReceiveDates invocations
func (mmUpdateReceiveDates *StorageMock) UpdateReceiveDatesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateReceiveDates.afterUpdateReceiveDatesCounter)
}

// UpdateReceiveDatesBeforeCounter returns a count of StorageMock.UpdateReceiveDates invocations
func (mmUpdateReceiveDates *StorageMock) UpdateReceiveDatesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateReceiveDates.beforeUpdateReceiveDatesCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.UpdateReceiveDates.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateReceiveDates *mStorageMockUpdateReceiveDates) Calls() []*StorageMockUpdateReceiveDatesParams {
	mmUpdateReceiveDates.mutex.RLock()

	argCopy := make([]*StorageMockUpdateReceiveDatesParams, len(mmUpdateReceiveDates.callArgs))
	copy(argCopy, mmUpdateReceiveDates.callArgs)

	mmUpdateReceiveDates.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateReceiveDatesDone returns true if the count of the UpdateReceiveDates invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockUpdateReceiveDatesDone() bool {
	if m.UpdateReceiveDatesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateReceiveDatesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateReceiveDatesMock.invocationsDone()
}

// MinimockUpdateReceiveDatesInspect logs each unmet expectation
func (m *StorageMock) MinimockUpdateReceiveDatesInspect() {
	for _, e := range m.UpdateReceiveDatesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.UpdateReceiveDates at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateReceiveDatesCounter := mm_atomic.LoadUint64(&m.afterUpdateReceiveDatesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateReceiveDatesMock.defaultExpectation != nil && afterUpdateReceiveDatesCounter < 1 {
		if m.UpdateReceiveDatesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.UpdateReceiveDates at\n%s", m.UpdateReceiveDatesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.UpdateReceiveDates at\n%s with params: %#v", m.UpdateReceiveDatesMock.defaultExpectation.expectationOrigins.origin, *m.UpdateReceiveDatesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateReceiveDates != nil && afterUpdateReceiveDatesCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.UpdateReceiveDates at\n%s", m.funcUpdateReceiveDatesOrigin)
	}

	if !m.UpdateReceiveDatesMock.invocationsDone() && afterUpdateReceiveDatesCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.UpdateReceiveDates at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateReceiveDatesMock.expectedInvocations), m.UpdateReceiveDatesMock.expectedInvocationsOrigin, afterUpdateReceiveDatesCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateOrderInspect()

			m.MinimockCreateReturnInspect()

			m.MinimockDeleteOrderInspect()

			m.MinimockGetOrderInspect()

			m.MinimockGetOrdersInspect()

			m.MinimockGetOrdersByUserIDInspect()

			m.MinimockGetReturnInspect()

			m.MinimockGetReturnsInspect()

			m.MinimockUpdateReceiveDatesInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateOrderDone() &&
		m.MinimockCreateReturnDone() &&
		m.MinimockDeleteOrderDone() &&
		m.MinimockGetOrderDone() &&
		m.MinimockGetOrdersDone() &&
		m.MinimockGetOrdersByUserIDDone() &&
		m.MinimockGetReturnDone() &&
		m.MinimockGetReturnsDone() &&
		m.MinimockUpdateReceiveDatesDone()
}
